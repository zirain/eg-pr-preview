<!doctype html><html itemscope itemtype=http://schema.org/WebPage lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=canonical type=text/html href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/><link rel=alternate type=application/rss+xml href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/index.xml><meta name=robots content="noindex, nofollow"><link rel="shortcut icon" href=/eg-pr-preview/5-test-docs-preview/favicons/favicon.ico><link rel=apple-touch-icon href=/eg-pr-preview/5-test-docs-preview/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/eg-pr-preview/5-test-docs-preview/favicons/android-192x192.png sizes=192x192><title>Security | Envoy Gateway</title>
<meta name=description content="This section includes security-related tasks."><meta property="og:url" content="https://zirain.github.io/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/"><meta property="og:site_name" content="Envoy Gateway"><meta property="og:title" content="Security"><meta property="og:description" content="This section includes security-related tasks."><meta property="og:locale" content="en"><meta property="og:type" content="website"><meta itemprop=name content="Security"><meta itemprop=description content="This section includes security-related tasks."><meta itemprop=dateModified content="2025-01-13T09:08:51+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Security"><meta name=twitter:description content="This section includes security-related tasks."><link rel=preload href=/eg-pr-preview/5-test-docs-preview/scss/main.min.13dd8d11b772c2d11eac755eb5d2d8924f18f01762c20defa026366a1f00937d.css as=style><link href=/eg-pr-preview/5-test-docs-preview/scss/main.min.13dd8d11b772c2d11eac755eb5d2d8924f18f01762c20defa026366a1f00937d.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.7.1.min.js integrity="sha512-v2CJ7UaYy4JwqLDIrZUI/4hqeoQieOmAZNXBeQyjo21dadnwR+8ZaIJVT8EE2iyI61OV8e6M8PP2/4hpQINQ/g==" crossorigin=anonymous></script><script defer src=https://unpkg.com/lunr@2.3.9/lunr.min.js integrity=sha384-203J0SNzyqHby3iU6hzvzltrWi/M41wOP5Gu+BiJMz5nwKykbkUx8Kp7iti0Lpli crossorigin=anonymous></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-DXJEH1ZRXX"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-DXJEH1ZRXX")}</script></head><body class=td-section><header><nav class="td-navbar js-navbar-scroll" data-bs-theme=dark><div class="container-fluid flex-column flex-md-row"><a class=navbar-brand href=/eg-pr-preview/5-test-docs-preview/><span class="navbar-brand__logo navbar-logo"><svg viewBox="0 0 1200 400"><defs><style>.cls-1{fill:#d04c9b}.cls-2{fill:#4a2365}.cls-3{fill:#b96aab}.cls-4{isolation:isolate}.cls-5{fill:#a53995}</style></defs><g><g id="Layer_1"><g><polygon id="polygon20" class="cls-5" points="191.2 242.29 190.55 213 159.76 193.83 160.4 223.12 191.2 242.29"/><path id="path22" class="cls-5" d="M234.92 315.52l-.65-28.65-26.92-16.8c-.43-.21-.86-.64-1.08-.86l.65 28.86 28 17.45h0z"/><path id="path24" class="cls-5" d="M138.65 354.07l-70.42-43.72-1.73-73.23 34.46-14.86-.65-29.29-55.14 23.69c-4.3 1.94-6.89 5.81-6.67 10.33l2.15 87.87c0 4.53 2.8 9.06 7.11 11.64l84.43 52.33c3.88 2.37 8.61 3.02 12.71 1.94.43-.21.86-.21 1.29-.43l51.9-22.39-28.21-17.45-31.23 13.57h0z"/><path id="path26" class="cls-3" d="M366.29 192.11c-.21-5.17-3.23-10.55-8.39-13.57l-102.52-63.53-3.23 1.29.64 30.8 81.19 50.4 1.94 82.27 31.01 19.17 1.72-.64-2.37-106.18h0z"/><path id="path28" class="cls-3" d="M243.53 336.62l-95.41-59.01-2.37-99.07 43.51-18.74-.86-34.24-67.41 29.07c-4.95 2.16-7.97 6.68-7.75 12.06l2.8 116.3c0 5.38 3.23 10.56 8.4 13.57l111.78 69.35c4.52 2.79 10.12 3.66 14.86 2.15.43-.22.86-.43 1.29-.43l65.9-28.44-32.73-20.25-42 17.67h0z"/><path id="path30" class="cls-1" d="M511.67 110.69 368.45 21.96c-5.38-3.23-11.62-4.1-17-2.37-.44.21-1.08.43-1.51.64L210.16 80.54c-5.6 2.37-9.04 7.54-8.83 13.78l3.44 149.04c.22 6.03 3.88 12.06 9.7 15.51l143.22 88.73c5.17 3.23 11.63 4.09 17.01 2.38.43-.22 1.08-.44 1.51-.65l139.78-60.3c5.59-2.37 9.05-7.75 8.84-13.79l-3.45-149.04c-.21-6.03-3.88-11.85-9.69-15.51M366.08 314.22 241.6 237.11l-3.02-129.44 121.47-52.33 124.49 77.1 3.02 129.45-121.47 52.33h0z"/></g><path id="path10" class="cls-2" d="M607.46 182.14c0 4.62 1.08 9.04 3.23 12.83 2.16 3.78 4.95 7.15 8.18 9.88 3.44 2.74 7.33 4.84 11.84 6.32 4.52 1.47 9.26 2.31 14 2.31 6.46.0 12.27-1.48 17.01-4.41 4.73-2.96 9.26-6.96 13.35-11.79L691 209.07c-11.63 14.71-27.99 22.08-48.88 22.08-8.61.0-16.58-1.47-23.69-4.41-7.11-2.96-13.13-6.95-17.88-12-4.95-5.05-8.61-11.15-11.19-17.88-2.58-6.94-3.88-14.31-3.88-22.51s1.51-15.57 4.31-22.51 6.89-12.83 11.84-17.88 10.98-9.04 18.09-12c6.9-2.94 14.65-4.42 22.83-4.42 9.69.0 18.09 1.69 24.77 5.06 6.67 3.36 12.27 7.77 16.58 13.03 4.31 5.48 7.54 11.37 9.48 18.31 1.94 6.73 3.01 13.67 3.01 20.62v7.37h-88.93v.21h0zM673.78 165.95c-.22-4.63-.86-8.64-2.15-12.42-1.29-3.79-3.23-7.15-6.03-9.89-2.59-2.74-6.02-5.05-9.91-6.53-3.88-1.69-8.61-2.31-13.78-2.31s-9.9 1.05-13.99 2.94c-4.31 1.88-7.97 4.42-10.77 7.36-3.01 2.94-5.17 6.31-6.89 10.1s-2.37 7.37-2.37 10.95h65.89v-.21h0z"/><path id="path12" class="cls-2" d="M714.26 120.71h20.89v16.61h.43c2.58-5.68 7.32-10.52 13.78-13.88 6.46-3.58 14-5.26 22.61-5.26 5.39.0 10.34.84 15.29 2.31 4.95 1.68 9.26 4.01 12.71 7.36 3.66 3.37 6.46 7.57 8.83 12.84 2.16 5.26 3.23 11.36 3.23 18.51v69.44h-20.89v-63.76c0-5.05-.65-9.25-2.15-12.83-1.3-3.58-3.23-6.53-5.6-8.64-2.37-2.1-4.95-3.79-7.97-4.83-3.01-1.06-6.24-1.48-9.47-1.48-4.3.0-8.4.63-12.06 2.1-3.66 1.48-6.89 3.58-9.68 6.53-2.8 2.94-4.96 6.73-6.47 11.35-1.5 4.63-2.37 9.89-2.37 16.21v55.55h-20.88V120.69h-.22v.02z"/><polygon id="polygon14" class="cls-2" points="843.03 120.71 875.98 203.4 907.63 120.71 930.03 120.71 886.74 228.64 863.71 228.64 818.7 120.71 843.03 120.71"/><path id="path16" class="cls-2" d="M931.53 174.77c0-7.78 1.51-15.15 4.53-22.09 3.01-6.73 7.1-12.83 12.49-17.88 5.38-5.06 11.41-9.26 18.73-12.2 7.12-2.95 14.86-4.42 23.04-4.42s15.93 1.47 23.04 4.42c7.1 2.94 13.36 6.93 18.73 12.2 5.17 5.25 9.48 11.15 12.5 17.88 3.01 6.73 4.53 14.1 4.53 22.09s-1.52 15.36-4.53 22.1c-3.02 6.94-7.11 12.83-12.5 17.88-5.37 5.05-11.4 9.04-18.73 12-7.11 2.94-14.85 4.41-23.04 4.41s-15.93-1.47-23.04-4.41c-7.1-2.96-13.35-6.95-18.73-12-5.39-5.05-9.48-11.15-12.49-17.88-3.01-6.94-4.53-14.31-4.53-22.1M953.71 174.77c0 5.47.86 10.52 2.59 15.15 1.71 4.62 4.09 8.62 7.31 11.79 3.02 3.37 6.9 5.89 11.42 7.78 4.52 1.89 9.48 2.94 15.08 2.94s10.55-.84 15.07-2.94c4.51-1.89 8.4-4.41 11.42-7.78 3-3.16 5.59-7.16 7.31-11.79 1.73-4.63 2.59-9.68 2.59-15.15s-.86-10.52-2.59-15.15c-1.71-4.63-4.09-8.63-7.31-11.78-3.02-3.15-6.9-5.89-11.42-7.78-4.52-1.89-9.48-2.94-15.07-2.94s-10.56 1.05-15.08 2.94c-4.52 1.9-8.39 4.42-11.42 7.78-3 3.37-5.59 7.15-7.31 11.78-1.73 4.63-2.59 9.68-2.59 15.15"/><path id="path18" class="cls-2" d="M1050.39 120.71h24.12l32.74 84.15h.42l31.44-84.15h22.4l-52.32 131.07c-1.94 4.63-3.88 9.05-5.82 12.84s-4.31 7.15-7.11 9.88c-2.79 2.73-6.25 4.84-10.12 6.31-3.88 1.48-8.82 2.31-14.43 2.31-3.02.0-6.24-.21-9.48-.62-3.22-.41-6.25-1.26-9.25-2.31l2.58-18.74c4.09 1.69 8.4 2.53 12.49 2.53 3.24.0 6.03-.42 8.18-1.26 2.16-.84 4.09-2.1 5.81-3.58 1.73-1.69 3.03-3.36 4.09-5.46 1.08-2.12 2.15-4.63 3.23-7.37l6.88-17.04-45.86-108.56h0z"/><g class="cls-4"><path class="cls-5" d="M636.86 328.23c0 8.4-2.15 14.77-6.44 19.14-4.3 4.36-10.51 6.54-18.65 6.54-4.53.0-8.61-.66-12.25-1.97s-7.1-3.58-10.38-6.79l5.51-6.3c2.43 2.62 5 4.61 7.72 5.95s5.85 2.02 9.4 2.02 6.25-.51 8.51-1.52c2.26-1.02 4.05-2.4 5.36-4.13 1.31-1.74 2.23-3.72 2.75-5.95.52-2.23.79-4.56.79-6.99v-5.9h-.2c-1.84 2.95-4.23 5.12-7.18 6.49-2.95 1.38-5.97 2.07-9.05 2.07-3.61.0-6.92-.59-9.94-1.77-3.02-1.18-5.61-2.82-7.77-4.92s-3.84-4.59-5.02-7.48c-1.18-2.89-1.77-6.03-1.77-9.45.0-3.74.59-7.12 1.77-10.13 1.18-3.02 2.84-5.56 4.97-7.62 2.13-2.07 4.71-3.66 7.72-4.77 3.02-1.11 6.36-1.67 10.04-1.67 1.57.0 3.15.18 4.72.54s3.1.92 4.58 1.67 2.8 1.71 3.98 2.85c1.18 1.15 2.17 2.48 2.95 3.98h.2v-7.87h7.67v43.98zm-40.34-20.95c0 2.36.43 4.54 1.28 6.54s2.02 3.74 3.49 5.21c1.48 1.48 3.2 2.64 5.17 3.49 1.97.85 4.07 1.28 6.3 1.28 2.62.0 4.95-.46 6.99-1.38 2.03-.92 3.75-2.15 5.17-3.69 1.41-1.54 2.48-3.31 3.2-5.31s1.08-4.12 1.08-6.35c0-2.49-.39-4.77-1.18-6.84s-1.9-3.85-3.34-5.36-3.18-2.67-5.21-3.49c-2.03-.82-4.26-1.23-6.69-1.23s-4.64.44-6.64 1.33c-2 .88-3.71 2.1-5.12 3.64-1.41 1.54-2.51 3.35-3.3 5.41-.79 2.07-1.18 4.31-1.18 6.74z"/><path class="cls-5" d="M650.44 290.16c2.36-2.43 5.17-4.21 8.41-5.36 3.25-1.15 6.54-1.72 9.89-1.72 6.82.0 11.74 1.61 14.76 4.82s4.53 8.1 4.53 14.66v19.78c0 1.31.06 2.67.2 4.08.13 1.41.3 2.71.49 3.89h-7.38c-.26-1.05-.41-2.21-.44-3.49-.03-1.28-.05-2.41-.05-3.39h-.2c-1.51 2.36-3.53 4.3-6.05 5.81-2.53 1.51-5.56 2.26-9.1 2.26-2.36.0-4.58-.29-6.64-.89-2.07-.59-3.87-1.46-5.41-2.61-1.54-1.15-2.77-2.57-3.69-4.28-.92-1.71-1.38-3.67-1.38-5.9.0-3.8.98-6.79 2.95-8.95 1.97-2.16 4.41-3.77 7.33-4.82 2.92-1.05 6.07-1.7 9.45-1.97 3.38-.26 6.48-.39 9.3-.39h2.95v-1.38c0-3.35-1-5.87-3-7.58s-4.81-2.56-8.41-2.56c-2.49.0-4.94.41-7.33 1.23-2.4.82-4.51 2.08-6.35 3.79l-4.82-5.02zM672.67 308.16c-4.92.0-8.82.69-11.71 2.07s-4.33 3.64-4.33 6.79c0 2.89.97 4.94 2.9 6.15s4.34 1.82 7.23 1.82c2.23.0 4.18-.38 5.85-1.13 1.67-.75 3.07-1.75 4.18-3 1.12-1.25 1.97-2.71 2.56-4.38.59-1.67.92-3.46.98-5.36v-2.95h-7.67z"/><path class="cls-5" d="M727.28 290.75H713.7v23.02c0 1.51.03 2.9.1 4.18.06 1.28.33 2.39.79 3.34.46.95 1.15 1.71 2.07 2.26.92.56 2.23.84 3.94.84 1.11.0 2.26-.13 3.44-.39 1.18-.26 2.3-.66 3.35-1.18l.29 6.99c-1.31.59-2.77 1.02-4.38 1.28s-3.13.39-4.58.39c-2.75.0-4.95-.36-6.59-1.08-1.64-.72-2.92-1.74-3.84-3.05-.92-1.31-1.52-2.93-1.82-4.87-.29-1.93-.44-4.08-.44-6.44v-25.29h-10.04v-6.49h10.04v-13.09h7.67v13.09h13.58v6.49z"/><path class="cls-5" d="M777.85 321.94c-2.75 3.54-5.77 6.02-9.05 7.43s-7.08 2.12-11.41 2.12c-3.61.0-6.85-.64-9.74-1.92-2.89-1.28-5.33-3-7.33-5.17s-3.54-4.72-4.62-7.67-1.62-6.1-1.62-9.45c0-3.54.59-6.8 1.77-9.79 1.18-2.98 2.82-5.54 4.92-7.67 2.1-2.13 4.59-3.79 7.48-4.97s6.03-1.77 9.45-1.77c3.21.0 6.17.54 8.86 1.62s5 2.66 6.94 4.72c1.93 2.07 3.43 4.59 4.48 7.58 1.05 2.99 1.57 6.38 1.57 10.18v2.46h-37.19c.13 1.97.61 3.85 1.43 5.66.82 1.81 1.88 3.38 3.2 4.72 1.31 1.35 2.85 2.41 4.62 3.2 1.77.79 3.71 1.18 5.8 1.18 3.35.0 6.17-.59 8.46-1.77 2.29-1.18 4.36-2.92 6.2-5.21l5.8 4.53zM771.26 303.14c-.13-3.94-1.41-7.08-3.84-9.45-2.43-2.36-5.77-3.54-10.04-3.54s-7.71 1.18-10.33 3.54-4.2 5.51-4.72 9.45h28.93z"/><path class="cls-5" d="M840.82 330.3h-7.58l-13.09-35.42h-.2l-11.61 35.42h-7.87l-14.96-46.05h8.46l10.53 35.42h.2l11.91-35.42h8.07l12.1 35.42h.2l10.43-35.42h8.26l-14.86 46.05z"/><path class="cls-5" d="M863.74 290.16c2.36-2.43 5.17-4.21 8.41-5.36 3.25-1.15 6.54-1.72 9.89-1.72 6.82.0 11.74 1.61 14.76 4.82s4.53 8.1 4.53 14.66v19.78c0 1.31.06 2.67.2 4.08.13 1.41.29 2.71.49 3.89h-7.38c-.26-1.05-.41-2.21-.44-3.49-.04-1.28-.05-2.41-.05-3.39h-.2c-1.51 2.36-3.53 4.3-6.05 5.81-2.53 1.51-5.56 2.26-9.1 2.26-2.36.0-4.58-.29-6.64-.89-2.07-.59-3.87-1.46-5.41-2.61-1.54-1.15-2.77-2.57-3.69-4.28-.92-1.71-1.38-3.67-1.38-5.9.0-3.8.98-6.79 2.95-8.95 1.97-2.16 4.41-3.77 7.33-4.82 2.92-1.05 6.07-1.7 9.45-1.97 3.38-.26 6.48-.39 9.3-.39h2.95v-1.38c0-3.35-1-5.87-3-7.58s-4.8-2.56-8.41-2.56c-2.49.0-4.94.41-7.33 1.23-2.4.82-4.51 2.08-6.35 3.79l-4.82-5.02zm22.24 18c-4.92.0-8.82.69-11.71 2.07s-4.33 3.64-4.33 6.79c0 2.89.97 4.94 2.9 6.15s4.34 1.82 7.23 1.82c2.23.0 4.18-.38 5.85-1.13 1.67-.75 3.07-1.75 4.18-3 1.12-1.25 1.97-2.71 2.56-4.38.59-1.67.92-3.46.98-5.36v-2.95h-7.68z"/><path class="cls-5" d="M932.32 340.83c-.79 1.97-1.59 3.75-2.41 5.36-.82 1.61-1.8 2.98-2.95 4.13-1.15 1.15-2.53 2.03-4.13 2.66-1.61.62-3.56.93-5.85.93-1.12.0-2.28-.07-3.49-.2s-2.35-.46-3.39-.98l.98-6.69c.79.33 1.61.54 2.46.64.85.1 1.84.15 2.95.15 2.49.0 4.33-.69 5.51-2.07s2.2-3.21 3.05-5.51l3.15-8.66-19.09-46.34h8.95l14.27 36.11h.2l13.68-36.11h8.36l-22.24 56.57z"/></g></g></g></svg></span><span class=navbar-brand__name>Envoy Gateway</span></a><div class="td-navbar-nav-scroll ms-md-auto" id=main_navbar><ul class=navbar-nav><li class=nav-item><a class=nav-link href=/eg-pr-preview/5-test-docs-preview/docs><span>Documentation</span></a></li><li class=nav-item><a class=nav-link href=/eg-pr-preview/5-test-docs-preview/news><span>News</span></a></li><li class=nav-item><a class=nav-link href=/eg-pr-preview/5-test-docs-preview/about><span>About</span></a></li><li class=nav-item><a class=nav-link href=/eg-pr-preview/5-test-docs-preview/contributions><span>Contributions</span></a></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>Versions</a><ul class=dropdown-menu><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//latest>latest</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//docs>v1.2</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v1.1>v1.1</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v1.0>v1.0</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v0.6>v0.6</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v0.5>v0.5</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v0.4>v0.4</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v0.3>v0.3</a></li><li><a class=dropdown-item href=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//v0.2>v0.2</a></li></ul></div></li><li class="nav-item dropdown d-none d-lg-block"><div class=dropdown><a class="nav-link dropdown-toggle" href=# role=button data-bs-toggle=dropdown aria-haspopup=true aria-expanded=false>English</a><ul class=dropdown-menu><li><a class=dropdown-item href=/eg-pr-preview/5-test-docs-preview/zh/>中文</a></li></ul></div></li></ul></div><div class="d-none d-lg-block"><div class="td-search td-search--offline"><div class=td-search__icon></div><input type=search class="td-search__input form-control" placeholder="Search this site…" aria-label="Search this site…" autocomplete=off data-offline-search-index-json-src=/eg-pr-preview/5-test-docs-preview/offline-search-index.59545f0114544c87ac67cca9eb52ae6d.json data-offline-search-base-href=/ data-offline-search-max-results=10></div></div></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><main class="col-12 col-md-9 col-xl-8 ps-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This is the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/>Return to the regular view of this page</a>.</p></div><h1 class=title>Security</h1><div class=lead>This section includes security-related tasks.</div><ul><li>1: <a href=#pg-35bafee9a49277d4e0365e62f8ec4462>Backend TLS: Gateway to Backend</a></li><li>2: <a href=#pg-88f0cc5d1149ed8265eee23aabbe9c74>Basic Authentication</a></li><li>3: <a href=#pg-f822ad6a79acd344f76ec920eea7869d>CORS</a></li><li>4: <a href=#pg-f341f81906bda6e94ffa720fd1d92710>External Authorization</a></li><li>5: <a href=#pg-65d9f20fa8d1969043272a52293fe854>JWT Authentication</a></li><li>6: <a href=#pg-10144bfde8f67d771dd86edb7f1735db>Mutual TLS: External Clients to the Gateway</a></li><li>7: <a href=#pg-854396c295e4654354ddca9ee76769ca>OIDC Authentication</a></li><li>8: <a href=#pg-808f08fa0c4dc6027e0cc518d6acd5e0>Secure Gateways</a></li><li>9: <a href=#pg-29400fabdf9ef11ec15d82b0616db296>Threat Model</a></li><li>10: <a href=#pg-4ba8db1bf690717020b2801692fdfb57>TLS Passthrough</a></li><li>11: <a href=#pg-713ead56ff8675156288cb286ef620f4>TLS Termination for TCP</a></li><li>12: <a href=#pg-59259f34ed2392ad6f2afc9f76e365cf>Using cert-manager For TLS Termination</a></li></ul><div class=content></div></div><div class=td-content><h1 id=pg-35bafee9a49277d4e0365e62f8ec4462>1 - Backend TLS: Gateway to Backend</h1><p>This task demonstrates how TLS can be achieved between the Gateway and a backend.
This task uses a self-signed CA, so it should be used for testing and demonstration purposes only.</p><p>Envoy Gateway supports the Gateway-API defined <a href=https://gateway-api.sigs.k8s.io/api-types/backendtlspolicy/>BackendTLSPolicy</a>.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>OpenSSL to generate TLS assets.</li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> to install Envoy Gateway and the example manifest.</p><h2 id=tls-certificates>TLS Certificates<a class=td-heading-self-link href=#tls-certificates aria-label="Heading self-link"></a></h2><p>Generate the certificates and keys used by the backend to terminate TLS connections from the Gateways.</p><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout ca.key -out ca.crt
</span></span></code></pre></div><p>Create a certificate and a private key for <code>www.example.com</code>.</p><p>First, create an openssl configuration file:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat &gt; openssl.conf  <span style=color:#4e9a06>&lt;&lt;EOF
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[req]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>req_extensions = v3_req
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>prompt = no
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[v3_req]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>keyUsage = keyEncipherment, digitalSignature
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>extendedKeyUsage = serverAuth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>subjectAltName = @alt_names
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>[alt_names]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>DNS.1 = www.example.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Then create a certificate using this openssl configuration file:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA ca.crt -CAkey ca.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.example.com.csr -out www.example.com.crt -extfile openssl.conf -extensions v3_req
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt
</span></span></code></pre></div><p>Store the CA Cert in another Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create configmap example-ca --from-file<span style=color:#ce5c00;font-weight:700>=</span>ca.crt
</span></span></code></pre></div><h2 id=setup-tls-on-the-backend>Setup TLS on the backend<a class=td-heading-self-link href=#setup-tls-on-the-backend aria-label="Heading self-link"></a></h2><p>Patch the existing quickstart backend to enable TLS. The patch will mount the TLS certificate secret into the backend as volume.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch deployment backend --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/template/spec/containers/0/volumeMounts
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      mountPath: /etc/secret-volume
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/template/spec/volumes
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: secret-volume
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      secret:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        secretName: example-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        items:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        - key: tls.crt
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          path: crt
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        - key: tls.key
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          path: key
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/template/spec/containers/0/env/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: TLS_SERVER_CERT
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      value: /etc/secret-volume/crt
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/template/spec/containers/0/env/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: TLS_SERVER_PRIVKEY
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      value: /etc/secret-volume/key
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Create a service that exposes port 443 on the backend service.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: v1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: Service
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  labels:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    app: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    service: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: tls-backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  namespace: default
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  selector:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    app: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  ports:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - name: https
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    protocol: TCP
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    targetPort: 8443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Create a <a href=https://gateway-api.sigs.k8s.io/api-types/backendtlspolicy/>BackendTLSPolicy</a> instructing Envoy Gateway to establish a TLS connection with the backend and validate the backend certificate is issued by a trusted CA and contains an appropriate DNS SAN.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1alpha2
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: BackendTLSPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: enable-backend-tls
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  namespace: default
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: &#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Service
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: tls-backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    sectionName: &#34;443&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    caCertRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: example-ca
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      group: &#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      kind: ConfigMap
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    hostname: www.example.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Patch the HTTPRoute&rsquo;s backend reference, so that it refers to the new TLS-enabled service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch HTTPRoute backend --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: replace
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/rules/0/backendRefs/0/port
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: replace
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/rules/0/backendRefs/0/name
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value: tls-backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Verify the HTTPRoute status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get HTTPRoute backend -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 80:80 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Query the TLS-enabled backend through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:80:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>http://www.example.com:80/get
</span></span></code></pre></div><p>Inspect the output and see that the response contains the details of the TLS handshake between Envoy and the backend:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt; HTTP/1.1 <span style=color:#0000cf;font-weight:700>200</span> OK
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span>...<span style=color:#ce5c00;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#4e9a06>&#34;tls&#34;</span>: <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;version&#34;</span>: <span style=color:#4e9a06>&#34;TLSv1.2&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;serverName&#34;</span>: <span style=color:#4e9a06>&#34;www.example.com&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;negotiatedProtocol&#34;</span>: <span style=color:#4e9a06>&#34;http/1.1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;cipherSuite&#34;</span>: <span style=color:#4e9a06>&#34;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><h3 id=clusters-with-external-loadbalancer-support>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the External IP of the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>GATEWAY_HOST</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get gateway/eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.addresses[0].value}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Query the example app through the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:80:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>http://www.example.com:80/get
</span></span></code></pre></div><p>Inspect the output and see that the response contains the details of the TLS handshake between Envoy and the backend:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt; HTTP/1.1 <span style=color:#0000cf;font-weight:700>200</span> OK
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>[</span>...<span style=color:#ce5c00;font-weight:700>]</span>
</span></span><span style=display:flex><span> <span style=color:#4e9a06>&#34;tls&#34;</span>: <span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;version&#34;</span>: <span style=color:#4e9a06>&#34;TLSv1.2&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;serverName&#34;</span>: <span style=color:#4e9a06>&#34;www.example.com&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;negotiatedProtocol&#34;</span>: <span style=color:#4e9a06>&#34;http/1.1&#34;</span>,
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;cipherSuite&#34;</span>: <span style=color:#4e9a06>&#34;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-88f0cc5d1149ed8265eee23aabbe9c74>2 - Basic Authentication</h1><p>This task provides instructions for configuring <a href=https://tools.ietf.org/html/rfc2617>HTTP Basic authentication</a>.
HTTP Basic authentication checks if an incoming request has a valid username and password before routing the request to
a backend service.</p><p>Envoy Gateway introduces a new CRD called <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> that allows the user to configure HTTP Basic
authentication.
This instantiated resource can be linked to a <a href=https://gateway-api.sigs.k8s.io/api-types/gateway>Gateway</a>, <a href=https://gateway-api.sigs.k8s.io/api-types/httproute>HTTPRoute</a> or <a href=https://gateway-api.sigs.k8s.io/api-types/grpcroute>GRPCRoute</a> resource.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=configuration>Configuration<a class=td-heading-self-link href=#configuration aria-label="Heading self-link"></a></h2><p>Envoy Gateway uses <a href=https://httpd.apache.org/docs/current/programs/htpasswd.html>.htpasswd</a> format to store the username-password pairs for authentication.
The file must be stored in a kubernetes secret and referenced in the <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> configuration.
The secret is an Opaque secret, and the username-password pairs must be stored in the key &ldquo;.htpasswd&rdquo;.</p><h3 id=create-a-root-certificate>Create a root certificate<a class=td-heading-self-link href=#create-a-root-certificate aria-label="Heading self-link"></a></h3><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout example.com.key -out example.com.crt
</span></span></code></pre></div><h3 id=create-a-certificate-secret>Create a certificate secret<a class=td-heading-self-link href=#create-a-certificate-secret aria-label="Heading self-link"></a></h3><p>Create a certificate and a private key for <code>www.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.example.com.csr -out www.example.com.crt
</span></span></code></pre></div><h3 id=create-certificate>Create certificate<a class=td-heading-self-link href=#create-certificate aria-label="Heading self-link"></a></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt
</span></span></code></pre></div><h3 id=enable-https>Enable HTTPS<a class=td-heading-self-link href=#enable-https aria-label="Heading self-link"></a></h3><p>Update the Gateway from the Quickstart to include an HTTPS listener that listens on port <code>443</code> and references the
<code>example-cert</code> Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: https
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            name: example-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><h3 id=create-a-htpasswd-file>Create a .htpasswd file<a class=td-heading-self-link href=#create-a-htpasswd-file aria-label="Heading self-link"></a></h3><p>First, create a <a href=https://httpd.apache.org/docs/current/programs/htpasswd.html>.htpasswd</a> file with the username and password you want to use for authentication.</p><p>Note: Please always use HTTPS with Basic Authentication. This prevents credentials from being transmitted in plain text.</p><p>The input password won&rsquo;t be saved, instead, a hash will be generated and saved in the output file. When a request
tries to access protected resources, the password in the &ldquo;Authorization&rdquo; HTTP header will be hashed and compared with the
saved hash.</p><p>Note: only SHA hash algorithm is supported for now.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>htpasswd -cbs .htpasswd foo bar
</span></span></code></pre></div><p>You can also add more users to the file:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>htpasswd -bs .htpasswd foo1 bar1
</span></span></code></pre></div><h3 id=create-a-basic-auth-secret>Create a basic-auth secret<a class=td-heading-self-link href=#create-a-basic-auth-secret aria-label="Heading self-link"></a></h3><p>Next, create a kubernetes secret with the generated .htpasswd file in the previous step.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic basic-auth --from-file<span style=color:#ce5c00;font-weight:700>=</span>.htpasswd
</span></span></code></pre></div><h3 id=create-a-securitypolicy>Create a SecurityPolicy<a class=td-heading-self-link href=#create-a-securitypolicy aria-label="Heading self-link"></a></h3><p>The below example defines a SecurityPolicy that authenticates requests against the user list in the kubernetes
secret generated in the previous step.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: basic-auth-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  basicAuth:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    users:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: &#34;basic-auth&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/basic-auth-example -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><p>Ensure the <code>GATEWAY_HOST</code> environment variable from the <a href=../../quickstart>Quickstart</a> is set. If not, follow the
Quickstart instructions to set the variable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$GATEWAY_HOST</span>
</span></span></code></pre></div><p>Send a request to the backend service without <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>&#34;http://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/&#34;</span>
</span></span></code></pre></div><p>You should see <code>401 Unauthorized</code> in the response, indicating that the request is not allowed without authentication.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>* Connected to 127.0.0.1 <span style=color:#ce5c00;font-weight:700>(</span>127.0.0.1<span style=color:#ce5c00;font-weight:700>)</span> port <span style=color:#0000cf;font-weight:700>443</span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>* Server certificate:
</span></span><span style=display:flex><span>*  subject: <span style=color:#000>CN</span><span style=color:#ce5c00;font-weight:700>=</span>www.example.com<span style=color:#000;font-weight:700>;</span> <span style=color:#000>O</span><span style=color:#ce5c00;font-weight:700>=</span>example organization
</span></span><span style=display:flex><span>*  issuer: <span style=color:#000>O</span><span style=color:#ce5c00;font-weight:700>=</span>example Inc.<span style=color:#000;font-weight:700>;</span> <span style=color:#000>CN</span><span style=color:#ce5c00;font-weight:700>=</span>example.com
</span></span><span style=display:flex><span>&gt; GET / HTTP/2
</span></span><span style=display:flex><span>&gt; Host: www.example.com
</span></span><span style=display:flex><span>&gt; User-Agent: curl/8.6.0
</span></span><span style=display:flex><span>&gt; Accept: */*
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt; HTTP/2 <span style=color:#0000cf;font-weight:700>401</span>
</span></span><span style=display:flex><span>&lt; content-length: <span style=color:#0000cf;font-weight:700>58</span>
</span></span><span style=display:flex><span>&lt; content-type: text/plain
</span></span><span style=display:flex><span>&lt; date: Wed, <span style=color:#0000cf;font-weight:700>06</span> Mar <span style=color:#0000cf;font-weight:700>2024</span> 15:59:36 GMT
</span></span><span style=display:flex><span>&lt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>* Connection <span style=color:#8f5902;font-style:italic>#0 to host 127.0.0.1 left intact</span>
</span></span><span style=display:flex><span>User authentication failed. Missing username and password.
</span></span></code></pre></div><p>Send a request to the backend service with <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -kv -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -u <span style=color:#4e9a06>&#39;foo:bar&#39;</span> <span style=color:#4e9a06>&#34;https://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/&#34;</span> 
</span></span></code></pre></div><p>The request should be allowed and you should see the response from the backend service.</p><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to uninstall Envoy Gateway and the example manifest.</p><p>Delete the SecurityPolicy and the secret</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete securitypolicy/basic-auth-example
</span></span><span style=display:flex><span>kubectl delete secret/basic-auth
</span></span><span style=display:flex><span>kubectl delete secret/example-cert
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f822ad6a79acd344f76ec920eea7869d>3 - CORS</h1><p>This guide provides instructions for configuring <a href=https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS>Cross-Origin Resource Sharing (CORS)</a> on Envoy Gateway.
CORS defines a way for client web applications that are loaded in one domain to interact with resources in a different
domain.</p><p>Envoy Gateway introduces a new CRD called <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> that allows the user to configure CORS.
This instantiated resource can be linked to a <a href=https://gateway-api.sigs.k8s.io/api-types/gateway>Gateway</a>, <a href=https://gateway-api.sigs.k8s.io/api-types/httproute>HTTPRoute</a> or <a href=https://gateway-api.sigs.k8s.io/api-types/grpcroute>GRPCRoute</a> resource.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> guide to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=configuration>Configuration<a class=td-heading-self-link href=#configuration aria-label="Heading self-link"></a></h2><p>When configuring CORS either an origin with a precise hostname can be configured or an hostname containing a wildcard prefix,
allowing all subdomains of the specified hostname.
In addition to that the entire origin (with or without specifying a scheme) can be a wildcard to allow all origins.</p><p>The below example defines a SecurityPolicy that allows CORS for all HTTP requests originating from <code>www.foo.com</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: cors-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  cors:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    allowOrigins:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;http://*.foo.com&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;http://*.foo.com:80&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    allowMethods:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - GET
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - POST
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    allowHeaders:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;x-header-1&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;x-header-2&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    exposeHeaders:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;x-header-3&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - &#34;x-header-4&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/cors-example -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><p>Ensure the <code>GATEWAY_HOST</code> environment variable from the <a href=../../quickstart>Quickstart</a> guide is set. If not, follow the
Quickstart instructions to set the variable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$GATEWAY_HOST</span>
</span></span></code></pre></div><p>Verify that the CORS headers are present in the response of the OPTIONS request from <code>http://www.foo.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -H <span style=color:#4e9a06>&#34;Origin: http://www.foo.com&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Access-Control-Request-Method: GET&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -X OPTIONS -v -s <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  http://<span style=color:#000>$GATEWAY_HOST</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  1&gt; /dev/null
</span></span></code></pre></div><p>You should see the below response, indicating that the request from <code>http://www.foo.com</code> is allowed:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>&lt; access-control-allow-origin: http://www.foo.com
</span></span><span style=display:flex><span>&lt; access-control-allow-methods: GET, POST
</span></span><span style=display:flex><span>&lt; access-control-allow-headers: x-header-1, x-header-2
</span></span><span style=display:flex><span>&lt; access-control-max-age: <span style=color:#0000cf;font-weight:700>86400</span>
</span></span><span style=display:flex><span>&lt; access-control-expose-headers: x-header-3, x-header-4
</span></span></code></pre></div><p>If you try to send a request from <code>http://www.bar.com</code>, you should see the below response:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -H <span style=color:#4e9a06>&#34;Origin: http://www.bar.com&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Access-Control-Request-Method: GET&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -X OPTIONS -v -s <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  http://<span style=color:#000>$GATEWAY_HOST</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  1&gt; /dev/null
</span></span></code></pre></div><p>You won&rsquo;t see any CORS headers in the response, indicating that the request from <code>http://www.bar.com</code> was not allowed.</p><p>If you try to send a request from <code>http://www.foo.com:8080</code>, you should also see similar response because the port number
<code>8080</code> is not included in the allowed origins.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#4e9a06>```</span>shell
</span></span><span style=display:flex><span>curl -H <span style=color:#4e9a06>&#34;Origin: http://www.foo.com:8080&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -H <span style=color:#4e9a06>&#34;Access-Control-Request-Method: GET&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  -X OPTIONS -v -s <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  http://<span style=color:#000>$GATEWAY_HOST</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>  1&gt; /dev/null
</span></span></code></pre></div><p>Note:</p><ul><li>CORS specification requires that the browsers to send a preflight request to the server to ask if it&rsquo;s allowed
to access the limited resource in another domains. The browsers are supposed to follow the response from the server to
determine whether to send the actual request or not. The CORS filter only response to the preflight requests according to
its configuration. It won&rsquo;t deny any requests. The browsers are responsible for enforcing the CORS policy.</li><li>The targeted HTTPRoute or the HTTPRoutes that the targeted Gateway routes to must allow the OPTIONS method for the CORS
filter to work. Otherwise, the OPTIONS request won&rsquo;t match the routes and the CORS filter won&rsquo;t be invoked.</li></ul><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> guide to uninstall Envoy Gateway and the example manifest.</p><p>Delete the SecurityPolicy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete securitypolicy/cors-example
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f341f81906bda6e94ffa720fd1d92710>4 - External Authorization</h1><p>This guide provides instructions for configuring external authentication.</p><p>External authorization calls an external HTTP or gRPC service to check whether an incoming HTTP request is authorized
or not. If the request is deemed unauthorized, then the request will be denied with a 403 (Forbidden) response. If the
request is authorized, then the request will be allowed to proceed to the backend service.</p><p>Envoy Gateway introduces a new CRD called <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> that allows the user to configure external authorization.
This instantiated resource can be linked to a <a href=https://gateway-api.sigs.k8s.io/api-types/gateway>Gateway</a> and <a href=https://gateway-api.sigs.k8s.io/api-types/httproute>HTTPRoute</a> resource.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> guide to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><h2 id=http-external-authorization-service>HTTP External Authorization Service<a class=td-heading-self-link href=#http-external-authorization-service aria-label="Heading self-link"></a></h2><h3 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h3><p>Install a demo HTTP service that will be used as the external authorization service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/ext-auth-http-service.yaml
</span></span></code></pre></div><p>Create a new HTTPRoute resource to route traffic on the path <code>/myapp</code> to the backend service.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  parentRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  hostnames:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - &#34;www.example.com&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  rules:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - matches:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - path:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        type: PathPrefix
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        value: /myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    backendRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 3000   
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the HTTPRoute status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get httproute/myapp -o yaml
</span></span></code></pre></div><h3 id=configuration>Configuration<a class=td-heading-self-link href=#configuration aria-label="Heading self-link"></a></h3><p>Create a new SecurityPolicy resource to configure the external authorization. This SecurityPolicy targets the HTTPRoute
&ldquo;myApp&rdquo; created in the previous step. It calls the HTTP external authorization service &ldquo;http-ext-auth&rdquo; on port 9002 for
authorization. The <code>headersToBackend</code> field specifies the headers that will be sent to the backend service if the request
is successfully authorized.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: ext-auth-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  extAuth:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    http:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      backendRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        name: http-ext-auth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        port: 9002
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      headersToBackend: [&#34;x-current-user&#34;]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/ext-auth-example -o yaml
</span></span></code></pre></div><h3 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h3><p>Ensure the <code>GATEWAY_HOST</code> environment variable from the <a href=../../quickstart>Quickstart</a> guide is set. If not, follow the
Quickstart instructions to set the variable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$GATEWAY_HOST</span>
</span></span></code></pre></div><p>Send a request to the backend service without <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>&#34;http://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/myapp&#34;</span>
</span></span></code></pre></div><p>You should see <code>403 Forbidden</code> in the response, indicating that the request is not allowed without authentication.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>* Connected to 172.18.255.200 <span style=color:#ce5c00;font-weight:700>(</span>172.18.255.200<span style=color:#ce5c00;font-weight:700>)</span> port <span style=color:#0000cf;font-weight:700>80</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#8f5902;font-style:italic>#0)</span>
</span></span><span style=display:flex><span>&gt; GET /myapp HTTP/1.1
</span></span><span style=display:flex><span>&gt; Host: www.example.com
</span></span><span style=display:flex><span>&gt; User-Agent: curl/7.68.0
</span></span><span style=display:flex><span>&gt; Accept: */*
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt; HTTP/1.1 <span style=color:#0000cf;font-weight:700>403</span> Forbidden
</span></span><span style=display:flex><span>&lt; date: Mon, <span style=color:#0000cf;font-weight:700>11</span> Mar <span style=color:#0000cf;font-weight:700>2024</span> 03:41:15 GMT
</span></span><span style=display:flex><span>&lt; x-envoy-upstream-service-time: <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>&lt; content-length: <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>&lt; 
</span></span><span style=display:flex><span>* Connection <span style=color:#8f5902;font-style:italic>#0 to host 172.18.255.200 left intact</span>
</span></span></code></pre></div><p>Send a request to the backend service with <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -H <span style=color:#4e9a06>&#34;Authorization: Bearer token1&#34;</span> <span style=color:#4e9a06>&#34;http://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/myapp&#34;</span>
</span></span></code></pre></div><p>The request should be allowed and you should see the response from the backend service.
Because the <code>x-current-user</code> header from the auth response has been sent to the backend service,
you should see the <code>x-current-user</code> header in the response.</p><pre tabindex=0><code>&#34;X-Current-User&#34;: [
   &#34;user1&#34;
  ],
</code></pre><h2 id=grpc-external-authorization-service>GRPC External Authorization Service<a class=td-heading-self-link href=#grpc-external-authorization-service aria-label="Heading self-link"></a></h2><h3 id=installation-1>Installation<a class=td-heading-self-link href=#installation-1 aria-label="Heading self-link"></a></h3><p>Install a demo gRPC service that will be used as the external authorization service. The demo gRPC service is enabled
with TLS and a BackendTLSConfig is created to configure the communication between the Envoy proxy and the gRPC service.</p><p>Note: TLS is optional for HTTP or gRPC external authorization services. However, enabling TLS is recommended for enhanced
security in production environments.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/ext-auth-grpc-service.yaml
</span></span></code></pre></div><p>The HTTPRoute created in the previous section is still valid and can be used with the gRPC auth service, but if you have
not created the HTTPRoute, you can create it now.</p><p>Create a new HTTPRoute resource to route traffic on the path <code>/myapp</code> to the backend service.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  parentRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  hostnames:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - &#34;www.example.com&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  rules:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - matches:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - path:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        type: PathPrefix
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        value: /myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    backendRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 3000   
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the HTTPRoute status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get httproute/myapp -o yaml
</span></span></code></pre></div><h3 id=configuration-1>Configuration<a class=td-heading-self-link href=#configuration-1 aria-label="Heading self-link"></a></h3><p>Update the SecurityPolicy that was created in the previous section to use the gRPC external authorization service.
It calls the gRPC external authorization service &ldquo;grpc-ext-auth&rdquo; on port 9002 for authorization.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: ext-auth-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  extAuth:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    grpc:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      backendRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        name: grpc-ext-auth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        port: 9002
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/ext-auth-example -o yaml
</span></span></code></pre></div><p>Because the gRPC external authorization service is enabled with TLS, a BackendTLSConfig needs to be created to configure
the communication between the Envoy proxy and the gRPC auth service.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1alpha2
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: BackendTLSPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: grpc-ext-auth-btls
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: &#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Service
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: grpc-ext-auth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    sectionName: &#34;9002&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    caCertRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: grpc-ext-auth-ca
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      group: &#39;&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      kind: ConfigMap
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    hostname: grpc-ext-auth
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Verify the BackendTLSPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get backendtlspolicy/grpc-ext-auth-btls -o yaml
</span></span></code></pre></div><h3 id=testing-1>Testing<a class=td-heading-self-link href=#testing-1 aria-label="Heading self-link"></a></h3><p>Ensure the <code>GATEWAY_HOST</code> environment variable from the <a href=../../quickstart>Quickstart</a> guide is set. If not, follow the
Quickstart instructions to set the variable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$GATEWAY_HOST</span>
</span></span></code></pre></div><p>Send a request to the backend service without <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> <span style=color:#4e9a06>&#34;http://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/myapp&#34;</span>
</span></span></code></pre></div><p>You should see <code>403 Forbidden</code> in the response, indicating that the request is not allowed without authentication.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>* Connected to 172.18.255.200 <span style=color:#ce5c00;font-weight:700>(</span>172.18.255.200<span style=color:#ce5c00;font-weight:700>)</span> port <span style=color:#0000cf;font-weight:700>80</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#8f5902;font-style:italic>#0)</span>
</span></span><span style=display:flex><span>&gt; GET /myapp HTTP/1.1
</span></span><span style=display:flex><span>&gt; Host: www.example.com
</span></span><span style=display:flex><span>&gt; User-Agent: curl/7.68.0
</span></span><span style=display:flex><span>&gt; Accept: */*
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>&lt; HTTP/1.1 <span style=color:#0000cf;font-weight:700>403</span> Forbidden
</span></span><span style=display:flex><span>&lt; date: Mon, <span style=color:#0000cf;font-weight:700>11</span> Mar <span style=color:#0000cf;font-weight:700>2024</span> 03:41:15 GMT
</span></span><span style=display:flex><span>&lt; x-envoy-upstream-service-time: <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>&lt; content-length: <span style=color:#0000cf;font-weight:700>0</span>
</span></span><span style=display:flex><span>&lt; 
</span></span><span style=display:flex><span>* Connection <span style=color:#8f5902;font-style:italic>#0 to host 172.18.255.200 left intact</span>
</span></span></code></pre></div><p>Send a request to the backend service with <code>Authentication</code> header:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -H <span style=color:#4e9a06>&#34;Authorization: Bearer token1&#34;</span> <span style=color:#4e9a06>&#34;http://</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>/myapp&#34;</span>
</span></span></code></pre></div><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> guide to uninstall Envoy Gateway and the example manifest.</p><p>Delete the demo auth services, HTTPRoute, SecurityPolicy and BackendTLSPolicy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/ext-auth-http-service.yaml
</span></span><span style=display:flex><span>kubectl delete -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/ext-auth-grpc-service.yaml
</span></span><span style=display:flex><span>kubectl delete httproute/myapp
</span></span><span style=display:flex><span>kubectl delete securitypolicy/ext-auth-example
</span></span><span style=display:flex><span>kubectl delete backendtlspolicy/grpc-ext-auth-btls
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-65d9f20fa8d1969043272a52293fe854>5 - JWT Authentication</h1><p>This guide provides instructions for configuring <a href=https://tools.ietf.org/html/rfc7519>JSON Web Token (JWT)</a> authentication. JWT authentication checks
if an incoming request has a valid JWT before routing the request to a backend service. Currently, Envoy Gateway only
supports validating a JWT from an HTTP header, e.g. <code>Authorization: Bearer &lt;token></code>.</p><p>Envoy Gateway introduces a new CRD called <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> that allows the user to configure JWT authentication.
This instantiated resource can be linked to a <a href=https://gateway-api.sigs.k8s.io/api-types/gateway>Gateway</a>, <a href=https://gateway-api.sigs.k8s.io/api-types/httproute>HTTPRoute</a> or <a href=https://gateway-api.sigs.k8s.io/api-types/grpcroute>GRPCRoute</a> resource.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> guide to install Envoy Gateway and the example manifest.
For GRPC - follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/traffic/grpc-routing/>GRPC Routing</a> example.
Before proceeding, you should be able to query the example backend using HTTP or GRPC.</p><h2 id=configuration>Configuration<a class=td-heading-self-link href=#configuration aria-label="Heading self-link"></a></h2><p>Allow requests with a valid JWT by creating an <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> and attaching it to the example
HTTPRoute or GRPCRoute.</p><h3 id=httproute>HTTPRoute<a class=td-heading-self-link href=#httproute aria-label="Heading self-link"></a></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/jwt/jwt.yaml
</span></span></code></pre></div><p>Two HTTPRoute has been created, one for <code>/foo</code> and another for <code>/bar</code>. A SecurityPolicy has been created and targeted
HTTPRoute foo to authenticate requests for <code>/foo</code>. The HTTPRoute bar is not targeted by the SecurityPolicy and will allow<br>unauthenticated requests to <code>/bar</code>.</p><p>Verify the HTTPRoute configuration and status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get httproute/foo -o yaml
</span></span><span style=display:flex><span>kubectl get httproute/bar -o yaml
</span></span></code></pre></div><p>The SecurityPolicy is configured for JWT authentication and uses a single <a href=https://tools.ietf.org/html/rfc7517>JSON Web Key Set (JWKS)</a>
provider for authenticating the JWT.</p><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/jwt-example -o yaml
</span></span></code></pre></div><h3 id=grpcroute>GRPCRoute<a class=td-heading-self-link href=#grpcroute aria-label="Heading self-link"></a></h3><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/jwt/grpc-jwt.yaml
</span></span></code></pre></div><p>A SecurityPolicy has been created and targeted GRPCRoute yages to authenticate all requests for <code>yages</code> service..</p><p>Verify the GRPCRoute configuration and status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get grpcroute/yages -o yaml
</span></span></code></pre></div><p>The SecurityPolicy is configured for JWT authentication and uses a single <a href=https://tools.ietf.org/html/rfc7517>JSON Web Key Set (JWKS)</a>
provider for authenticating the JWT.</p><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/jwt-example -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><p>Ensure the <code>GATEWAY_HOST</code> environment variable from the <a href=../../quickstart>Quickstart</a> guide is set. If not, follow the
Quickstart instructions to set the variable.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>echo</span> <span style=color:#000>$GATEWAY_HOST</span>
</span></span></code></pre></div><h3 id=httproute-1>HTTPRoute<a class=td-heading-self-link href=#httproute-1 aria-label="Heading self-link"></a></h3><p>Verify that requests to <code>/foo</code> are denied without a JWT:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sS -o /dev/null -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -w <span style=color:#4e9a06>&#34;%{http_code}\n&#34;</span> http://<span style=color:#000>$GATEWAY_HOST</span>/foo
</span></span></code></pre></div><p>A <code>401</code> HTTP response code should be returned.</p><p>Get the JWT used for testing request authentication:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>TOKEN</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>curl https://raw.githubusercontent.com/envoyproxy/gateway/main/examples/kubernetes/jwt/test.jwt -s<span style=color:#204a87;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$TOKEN</span><span style=color:#4e9a06>&#34;</span> <span style=color:#000;font-weight:700>|</span> cut -d <span style=color:#4e9a06>&#39;.&#39;</span> -f2 - <span style=color:#000;font-weight:700>|</span> base64 --decode
</span></span></code></pre></div><p><strong>Note:</strong> The above command decodes and returns the token&rsquo;s payload. You can replace <code>f2</code> with <code>f1</code> to view the token&rsquo;s
header.</p><p>Verify that a request to <code>/foo</code> with a valid JWT is allowed:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sS -o /dev/null -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -H <span style=color:#4e9a06>&#34;Authorization: Bearer </span><span style=color:#000>$TOKEN</span><span style=color:#4e9a06>&#34;</span> -w <span style=color:#4e9a06>&#34;%{http_code}\n&#34;</span> http://<span style=color:#000>$GATEWAY_HOST</span>/foo
</span></span></code></pre></div><p>A <code>200</code> HTTP response code should be returned.</p><p>Verify that requests to <code>/bar</code> are allowed <strong>without</strong> a JWT:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sS -o /dev/null -H <span style=color:#4e9a06>&#34;Host: www.example.com&#34;</span> -w <span style=color:#4e9a06>&#34;%{http_code}\n&#34;</span> http://<span style=color:#000>$GATEWAY_HOST</span>/bar
</span></span></code></pre></div><h3 id=grpcroute-1>GRPCRoute<a class=td-heading-self-link href=#grpcroute-1 aria-label="Heading self-link"></a></h3><p>Verify that requests to <code>yages</code>service are denied without a JWT:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>grpcurl -plaintext -authority<span style=color:#ce5c00;font-weight:700>=</span>grpc-example.com <span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span>:80 yages.Echo/Ping
</span></span></code></pre></div><p>You should see the below response</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Error invoking method <span style=color:#4e9a06>&#34;yages.Echo/Ping&#34;</span>: rpc error: <span style=color:#000>code</span> <span style=color:#ce5c00;font-weight:700>=</span> Unauthenticated <span style=color:#000>desc</span> <span style=color:#ce5c00;font-weight:700>=</span> failed to query <span style=color:#204a87;font-weight:700>for</span> service descriptor <span style=color:#4e9a06>&#34;yages.Echo&#34;</span>: Jwt is missing
</span></span></code></pre></div><p>Get the JWT used for testing request authentication:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#000>TOKEN</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>curl https://raw.githubusercontent.com/envoyproxy/gateway/main/examples/kubernetes/jwt/test.jwt -s<span style=color:#204a87;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#204a87>echo</span> <span style=color:#4e9a06>&#34;</span><span style=color:#000>$TOKEN</span><span style=color:#4e9a06>&#34;</span> <span style=color:#000;font-weight:700>|</span> cut -d <span style=color:#4e9a06>&#39;.&#39;</span> -f2 - <span style=color:#000;font-weight:700>|</span> base64 --decode
</span></span></code></pre></div><p><strong>Note:</strong> The above command decodes and returns the token&rsquo;s payload. You can replace <code>f2</code> with <code>f1</code> to view the token&rsquo;s
header.</p><p>Verify that a request to <code>yages</code> service with a valid JWT is allowed:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>grpcurl -plaintext -H <span style=color:#4e9a06>&#34;authorization: Bearer </span><span style=color:#000>$TOKEN</span><span style=color:#4e9a06>&#34;</span> -authority<span style=color:#ce5c00;font-weight:700>=</span>grpc-example.com <span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span>:80 yages.Echo/Ping
</span></span></code></pre></div><p>You should see the below response</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>{</span>
</span></span><span style=display:flex><span>  <span style=color:#4e9a06>&#34;text&#34;</span>: <span style=color:#4e9a06>&#34;pong&#34;</span>
</span></span><span style=display:flex><span><span style=color:#ce5c00;font-weight:700>}</span>
</span></span></code></pre></div><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> guide to uninstall Envoy Gateway and the example manifest.</p><p>Delete the SecurityPolicy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete securitypolicy/jwt-example
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-10144bfde8f67d771dd86edb7f1735db>6 - Mutual TLS: External Clients to the Gateway</h1><p>This task demonstrates how mutual TLS can be achieved between external clients and the Gateway.
This task uses a self-signed CA, so it should be used for testing and demonstration purposes only.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>OpenSSL to generate TLS assets.</li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=tls-certificates>TLS Certificates<a class=td-heading-self-link href=#tls-certificates aria-label="Heading self-link"></a></h2><p>Generate the certificates and keys used by the Gateway to terminate client TLS connections.</p><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout example.com.key -out example.com.crt
</span></span></code></pre></div><p>Create a certificate and a private key for <code>www.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.example.com.csr -out www.example.com.crt
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt --certificate-authority<span style=color:#ce5c00;font-weight:700>=</span>example.com.crt
</span></span></code></pre></div><p>Store the CA Cert in another Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic example-ca-cert --from-file<span style=color:#ce5c00;font-weight:700>=</span>ca.crt<span style=color:#ce5c00;font-weight:700>=</span>example.com.crt
</span></span></code></pre></div><p>Create a certificate and a private key for the client <code>client.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out client.example.com.csr -newkey rsa:2048 -nodes -keyout client.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=client.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in client.example.com.csr -out client.example.com.crt
</span></span></code></pre></div><p>Update the Gateway from the Quickstart to include an HTTPS listener that listens on port <code>443</code> and references the
<code>example-cert</code> Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: https
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            name: example-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><p>Create a <a href=../../../api/extension_types#clienttrafficpolicy>ClientTrafficPolicy</a> to enforce client validation using the CA Certificate as a trusted anchor.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: ClientTrafficPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: enable-mtls
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  namespace: default
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    namespace: default
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    clientValidation:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      caCertificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      - kind: &#34;Secret&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        name: &#34;example-ca-cert&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 8443:443 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Query the example app through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cert client.example.com.crt --key client.example.com.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get
</span></span></code></pre></div><h3 id=clusters-with-external-loadbalancer-support>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the External IP of the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>GATEWAY_HOST</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get gateway/eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.addresses[0].value}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Query the example app through the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:443:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cert client.example.com.crt --key client.example.com.key <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com/get
</span></span></code></pre></div><p>Dont specify the client key and certificate in the above command, and ensure that the connection fails</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:443:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com/get
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-854396c295e4654354ddca9ee76769ca>7 - OIDC Authentication</h1><p>This task provides instructions for configuring <a href=https://openid.net/connect/>OpenID Connect (OIDC)</a> authentication.
OpenID Connect (OIDC) is an authentication standard built on top of OAuth 2.0.
It enables EG to rely on authentication that is performed by an OpenID Connect Provider (OP)
to verify the identity of a user.</p><p>Envoy Gateway introduces a new CRD called <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/security-policy/>SecurityPolicy</a> that allows the user to configure OIDC
authentication.
This instantiated resource can be linked to a <a href=https://gateway-api.sigs.k8s.io/api-types/gateway>Gateway</a> and <a href=https://gateway-api.sigs.k8s.io/api-types/httproute>HTTPRoute</a> resource.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><p>EG OIDC authentication requires the redirect URL to be HTTPS. Follow the <a href=../secure-gateways>Secure Gateways</a> guide
to generate the TLS certificates and update the Gateway configuration to add an HTTPS listener.</p><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><p>Let&rsquo;s create an HTTPRoute that represents an application protected by OIDC.</p><ul class="nav nav-tabs" id=tabs-0 role=tablist><li class=nav-item><button class="nav-link active" id=tabs-00-00-tab data-bs-toggle=tab data-bs-target=#tabs-00-00 role=tab data-td-tp-persist="apply from stdin" aria-controls=tabs-00-00 aria-selected=true>
Apply from stdin</button></li><li class=nav-item><button class=nav-link id=tabs-00-01-tab data-bs-toggle=tab data-bs-target=#tabs-00-01 role=tab data-td-tp-persist="apply from file" aria-controls=tabs-00-01 aria-selected=false>
Apply from file</button></li></ul><div class=tab-content id=tabs-0-content><div class="tab-body tab-pane fade show active" id=tabs-00-00 role=tabpanel aria-labelled-by=tabs-00-00-tab tabindex=0><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  parentRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  hostnames: [&#34;www.example.com&#34;]
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  rules:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - matches:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - path:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        type: PathPrefix
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        value: /myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    backendRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: backend
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 3000
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div></div><div class="tab-body tab-pane fade" id=tabs-00-01 role=tabpanel aria-labelled-by=tabs-00-01-tab tabindex=0><p>Save and apply the following resource to your cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gateway.networking.k8s.io/v1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>HTTPRoute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myapp</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>parentRefs</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>eg</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>hostnames</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000;font-weight:700>[</span><span style=color:#4e9a06>&#34;www.example.com&#34;</span><span style=color:#000;font-weight:700>]</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>rules</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>matches</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#204a87;font-weight:700>path</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>type</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>PathPrefix</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>        </span><span style=color:#204a87;font-weight:700>value</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>/myapp</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>backendRefs</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>backend</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>port</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>3000</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div></div><p>Verify the HTTPRoute status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get httproute/myapp -o yaml
</span></span></code></pre></div><h2 id=oidc-authentication-for-a-httproute>OIDC Authentication for a HTTPRoute<a class=td-heading-self-link href=#oidc-authentication-for-a-httproute aria-label="Heading self-link"></a></h2><p>OIDC can be configured at the Gateway level to authenticate all the HTTPRoutes that are associated with the Gateway with
the same OIDC configuration, or at the HTTPRoute level to authenticate each HTTPRoute with different OIDC configurations.</p><p>This section demonstrates how to configure OIDC authentication for a specific HTTPRoute.</p><h3 id=register-an-oidc-application>Register an OIDC application<a class=td-heading-self-link href=#register-an-oidc-application aria-label="Heading self-link"></a></h3><p>This task uses Google as the OIDC provider to demonstrate the configuration of OIDC. However, EG works with any OIDC
providers, including Auth0, Azure AD, Keycloak, Okta, OneLogin, Salesforce, UAA, etc.</p><p>Follow the steps in the <a href=https://developers.google.com/identity/protocols/oauth2/openid-connect>Google OIDC documentation</a> to register an OIDC application. Please make sure the
redirect URL is set to the one you configured in the SecurityPolicy that you will create in the step below. In this example,
the redirect URL is <code>http://www.example.com:8443/myapp/oauth2/callback</code>.</p><p>After registering the application, you should have the following information:</p><ul><li>Client ID: The client ID of the OIDC application.</li><li>Client Secret: The client secret of the OIDC application.</li></ul><h3 id=create-a-kubernetes-secret>Create a kubernetes secret<a class=td-heading-self-link href=#create-a-kubernetes-secret aria-label="Heading self-link"></a></h3><p>Next, create a kubernetes secret with the Client Secret created in the previous step. The secret is an Opaque secret,
and the Client Secret must be stored in the key &ldquo;client-secret&rdquo;.</p><p>Note: please replace the ${CLIENT_SECRET} with the actual Client Secret that you got from the previous step.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret generic my-app-client-secret --from-literal<span style=color:#ce5c00;font-weight:700>=</span>client-secret<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>${</span><span style=color:#000>CLIENT_SECRET</span><span style=color:#4e9a06>}</span>
</span></span></code></pre></div><h3 id=create-a-securitypolicy>Create a SecurityPolicy<a class=td-heading-self-link href=#create-a-securitypolicy aria-label="Heading self-link"></a></h3><p><strong>Please notice that the <code>redirectURL</code> and <code>logoutPath</code> must match the target HTTPRoute.</strong> In this example, the target
HTTPRoute is configured to match the host <code>www.example.com</code> and the path <code>/myapp</code>, so the <code>redirectURL</code> must be prefixed
with <code>https://www.example.com:8443/myapp</code>, and <code>logoutPath</code> must be prefixed with<code>/myapp</code>, otherwise the OIDC authentication
will fail because the redirect and logout requests will not match the target HTTPRoute and therefore can&rsquo;t be processed
by the OAuth2 filter on that HTTPRoute.</p><p>Note: please replace the ${CLIENT_ID} in the below yaml snippet with the actual Client ID that you got from the OIDC provider.</p><ul class="nav nav-tabs" id=tabs-1 role=tablist><li class=nav-item><button class="nav-link active" id=tabs-01-00-tab data-bs-toggle=tab data-bs-target=#tabs-01-00 role=tab data-td-tp-persist="apply from stdin" aria-controls=tabs-01-00 aria-selected=true>
Apply from stdin</button></li><li class=nav-item><button class=nav-link id=tabs-01-01-tab data-bs-toggle=tab data-bs-target=#tabs-01-01 role=tab data-td-tp-persist="apply from file" aria-controls=tabs-01-01 aria-selected=false>
Apply from file</button></li></ul><div class=tab-content id=tabs-1-content><div class="tab-body tab-pane fade show active" id=tabs-01-00 role=tabpanel aria-labelled-by=tabs-01-00-tab tabindex=1><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: oidc-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: HTTPRoute
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: myapp
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  oidc:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    provider:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      issuer: &#34;https://accounts.google.com&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    clientID: &#34;${CLIENT_ID}&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    clientSecret:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: &#34;my-app-client-secret&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    redirectURL: &#34;https://www.example.com:8443/myapp/oauth2/callback&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    logoutPath: &#34;/myapp/logout&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div></div><div class="tab-body tab-pane fade" id=tabs-01-01 role=tabpanel aria-labelled-by=tabs-01-01-tab tabindex=1><p>Save and apply the following resource to your cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gateway.envoyproxy.io/v1alpha1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SecurityPolicy</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>oidc-example</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>targetRef</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gateway.networking.k8s.io</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>HTTPRoute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>myapp</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>oidc</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>provider</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>issuer</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;https://accounts.google.com&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>clientID</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;${CLIENT_ID}&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>clientSecret</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;my-app-client-secret&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>redirectURL</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;https://www.example.com:8443/myapp/oauth2/callback&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>logoutPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;/myapp/logout&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/oidc-example -o yaml
</span></span></code></pre></div><h3 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h3><p>Port forward gateway port to localhost:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 8443:443
</span></span></code></pre></div><p>Put <a href=https://www.example.com>www.example.com</a> in the /etc/hosts file in your test machine, so we can use this host name to access the gateway from a browser:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>...
</span></span><span style=display:flex><span>127.0.0.1 www.example.com
</span></span></code></pre></div><p>Open a browser and navigate to the <code>https://www.example.com:8443/myapp</code> address. You should be redirected to the Google
login page. After you successfully login, you should see the response from the backend service.</p><p>Clean the cookies in the browser and try to access <code>https://www.example.com:8443/foo</code> address. You should be able to see
this page since the path <code>/foo</code> is not protected by the OIDC policy.</p><h2 id=oidc-authentication-for-a-gateway>OIDC Authentication for a Gateway<a class=td-heading-self-link href=#oidc-authentication-for-a-gateway aria-label="Heading self-link"></a></h2><p>OIDC can be configured at the Gateway level to authenticate all the HTTPRoutes that are associated with the Gateway with
the same OIDC configuration, or at the HTTPRoute level to authenticate each HTTPRoute with different OIDC configurations.</p><p>This section demonstrates how to configure OIDC authentication for a Gateway.</p><h3 id=register-an-oidc-application-1>Register an OIDC application<a class=td-heading-self-link href=#register-an-oidc-application-1 aria-label="Heading self-link"></a></h3><p>If you haven&rsquo;t registered an OIDC application, follow the steps in the previous section to register an OIDC application.</p><h3 id=create-a-kubernetes-secret-1>Create a kubernetes secret<a class=td-heading-self-link href=#create-a-kubernetes-secret-1 aria-label="Heading self-link"></a></h3><p>If you haven&rsquo;t created a kubernetes secret, follow the steps in the previous section to create a kubernetes secret.</p><h3 id=create-a-securitypolicy-1>Create a SecurityPolicy<a class=td-heading-self-link href=#create-a-securitypolicy-1 aria-label="Heading self-link"></a></h3><p>Create or update the SecurityPolicy to target the Gateway instead of the HTTPRoute. <strong>Please notice that the <code>redirectURL</code>
and <code>logoutPath</code> must match one of the HTTPRoutes associated with the Gateway.</strong> In this example, the target Gateway has
two HTTPRoutes associated with it, one with the host <code>www.example.com</code> and the path <code>/myapp</code>, and the other with the host
<code>www.example.com</code> and the path <code>/</code>. Either one of the HTTPRoutes can be used to match the <code>redirectURL</code> and <code>logoutPath</code>.</p><ul class="nav nav-tabs" id=tabs-2 role=tablist><li class=nav-item><button class="nav-link active" id=tabs-02-00-tab data-bs-toggle=tab data-bs-target=#tabs-02-00 role=tab data-td-tp-persist="apply from stdin" aria-controls=tabs-02-00 aria-selected=true>
Apply from stdin</button></li><li class=nav-item><button class=nav-link id=tabs-02-01-tab data-bs-toggle=tab data-bs-target=#tabs-02-01 role=tab data-td-tp-persist="apply from file" aria-controls=tabs-02-01 aria-selected=false>
Apply from file</button></li></ul><div class=tab-content id=tabs-2-content><div class="tab-body tab-pane fade show active" id=tabs-02-00 role=tabpanel aria-labelled-by=tabs-02-00-tab tabindex=2><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.envoyproxy.io/v1alpha1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: SecurityPolicy
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: oidc-example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  targetRef:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  oidc:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    provider:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      issuer: &#34;https://accounts.google.com&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    clientID: &#34;${CLIENT_ID}&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    clientSecret:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: &#34;my-app-client-secret&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    redirectURL: &#34;https://www.example.com:8443/myapp/oauth2/callback&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    logoutPath: &#34;/myapp/logout&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div></div><div class="tab-body tab-pane fade" id=tabs-02-01 role=tabpanel aria-labelled-by=tabs-02-01-tab tabindex=2><p>Save and apply the following resource to your cluster:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>apiVersion</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gateway.envoyproxy.io/v1alpha1</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>SecurityPolicy</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>metadata</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>oidc-example</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>spec</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>targetRef</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>group</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>gateway.networking.k8s.io</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>kind</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>Gateway</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>eg</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>oidc</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>provider</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>issuer</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;https://accounts.google.com&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>clientID</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;${CLIENT_ID}&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>clientSecret</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>      </span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;my-app-client-secret&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>redirectURL</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;https://www.example.com:8443/myapp/oauth2/callback&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>logoutPath</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#34;/myapp/logout&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div></div></div><p>Verify the SecurityPolicy configuration:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get securitypolicy/oidc-example -o yaml
</span></span></code></pre></div><h3 id=testing-1>Testing<a class=td-heading-self-link href=#testing-1 aria-label="Heading self-link"></a></h3><p>If you haven&rsquo;t done so, follow the steps in the previous section to port forward gateway port to localhost and put
<a href=https://www.example.com>www.example.com</a> in the /etc/hosts file in your test machine.</p><p>Open a browser and navigate to the <code>https://www.example.com:8443/foo</code> address. You should be redirected to the Google
login page. After you successfully login, you should see the response from the backend service.</p><p>You can also try to access <code>https://www.example.com:8443/myapp</code> address. You should be able to see this page since the
path <code>/myapp</code> is protected by the same OIDC policy.</p><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to uninstall Envoy Gateway and the example manifest.</p><p>Delete the SecurityPolicy, the secret and the HTTPRoute:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete securitypolicy/oidc-example
</span></span><span style=display:flex><span>kubectl delete secret/my-app-client-secret
</span></span><span style=display:flex><span>kubectl delete httproute/myapp
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-808f08fa0c4dc6027e0cc518d6acd5e0>8 - Secure Gateways</h1><p>This task will help you get started using secure Gateways.
This task uses a self-signed CA, so it should be used for testing and demonstration purposes only.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>OpenSSL to generate TLS assets.</li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=tls-certificates>TLS Certificates<a class=td-heading-self-link href=#tls-certificates aria-label="Heading self-link"></a></h2><p>Generate the certificates and keys used by the Gateway to terminate client TLS connections.</p><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout example.com.key -out example.com.crt
</span></span></code></pre></div><p>Create a certificate and a private key for <code>www.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.example.com.csr -out www.example.com.crt
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt
</span></span></code></pre></div><p>Update the Gateway from the Quickstart to include an HTTPS listener that listens on port <code>443</code> and references the
<code>example-cert</code> Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: https
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          name: example-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 8443:443 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Query the example app through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get
</span></span></code></pre></div><h3 id=clusters-with-external-loadbalancer-support>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the External IP of the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>GATEWAY_HOST</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get gateway/eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.addresses[0].value}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Query the example app through the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:443:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com/get
</span></span></code></pre></div><h2 id=multiple-https-listeners>Multiple HTTPS Listeners<a class=td-heading-self-link href=#multiple-https-listeners aria-label="Heading self-link"></a></h2><p>Create a TLS cert/key for the additional HTTPS listener:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out foo.example.com.csr -newkey rsa:2048 -nodes -keyout foo.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=foo.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in foo.example.com.csr -out foo.example.com.crt
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls foo-cert --key<span style=color:#ce5c00;font-weight:700>=</span>foo.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>foo.example.com.crt
</span></span></code></pre></div><p>Create another HTTPS listener on the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: https-foo
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      hostname: foo.example.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          name: foo-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Update the HTTPRoute to route traffic for hostname <code>foo.example.com</code> to the example backend service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch httproute backend --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/hostnames/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value: foo.example.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><p>Follow the steps in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#testing>Testing section</a> to test connectivity to the backend app through both Gateway
listeners. Replace <code>www.example.com</code> with <code>foo.example.com</code> to test the new HTTPS listener.</p><h2 id=cross-namespace-certificate-references>Cross Namespace Certificate References<a class=td-heading-self-link href=#cross-namespace-certificate-references aria-label="Heading self-link"></a></h2><p>A Gateway can be configured to reference a certificate in a different namespace. This is allowed by a <a href=https://gateway-api.sigs.k8s.io/api-types/referencegrant/>ReferenceGrant</a>
created in the target namespace. Without the ReferenceGrant, a cross-namespace reference is invalid.</p><p>Before proceeding, ensure you can query the HTTPS backend service from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#testing>Testing section</a>.</p><p>To demonstrate cross namespace certificate references, create a ReferenceGrant that allows Gateways from the &ldquo;default&rdquo;
namespace to reference Secrets in the &ldquo;envoy-gateway-system&rdquo; namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1beta1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: ReferenceGrant
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: example
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  namespace: envoy-gateway-system
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  from:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - group: gateway.networking.k8s.io
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    namespace: default
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  to:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>Delete the previously created Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret/example-cert
</span></span></code></pre></div><p>The Gateway HTTPS listener should now surface the <code>Ready: False</code> status condition and the example HTTPS backend should
no longer be reachable through the Gateway.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><p>Recreate the example Secret in the <code>envoy-gateway-system</code> namespace:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert -n envoy-gateway-system --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt
</span></span></code></pre></div><p>Update the Gateway HTTPS listener with <code>namespace: envoy-gateway-system</code>, for example:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>cat <span style=color:#4e9a06>&lt;&lt;EOF | kubectl apply -f -
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>apiVersion: gateway.networking.k8s.io/v1
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>metadata:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  name: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>spec:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  gatewayClassName: eg
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  listeners:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: http
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTP
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 80
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    - name: https
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>          - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            group: &#34;&#34;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            name: example-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>            namespace: envoy-gateway-system
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>EOF</span>
</span></span></code></pre></div><p>The Gateway HTTPS listener status should now surface the <code>Ready: True</code> condition and you should once again be able to
query the HTTPS backend through the Gateway.</p><p>Lastly, test connectivity using the above <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#testing>Testing section</a>.</p><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> to uninstall Envoy Gateway and the example manifest.</p><p>Delete the Secrets:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret/example-cert
</span></span><span style=display:flex><span>kubectl delete secret/foo-cert
</span></span></code></pre></div><h1 id=rsa--ecdsa-dual-stack-certificates>RSA + ECDSA Dual stack certificates<a class=td-heading-self-link href=#rsa--ecdsa-dual-stack-certificates aria-label="Heading self-link"></a></h1><p>This section gives a walkthrough to generate RSA and ECDSA derived certificates and keys for the Server, which can then be configured in the Gateway listener, to terminate TLS traffic.</p><h2 id=prerequisites-1>Prerequisites<a class=td-heading-self-link href=#prerequisites-1 aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><p>Follow the steps in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#tls-certificates>TLS Certificates</a> section to generate self-signed RSA derived Server certificate and private key, and configure those in the Gateway listener configuration to terminate HTTPS traffic.</p><h2 id=pre-checks>Pre-checks<a class=td-heading-self-link href=#pre-checks aria-label="Heading self-link"></a></h2><p>While testing in <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#clusters-without-external-loadbalancer-support>Cluster without External LoadBalancer Support</a>, we can query the example app through Envoy proxy while enforcing an RSA cipher, as shown below:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get  -Isv --ciphers ECDHE-RSA-CHACHA20-POLY1305 --tlsv1.2 --tls-max 1.2
</span></span></code></pre></div><p>Since the Secret configured at this point is an RSA based Secret, if we enforce the usage of an ECDSA cipher, the call should fail as follows</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get  -Isv --ciphers ECDHE-ECDSA-CHACHA20-POLY1305 --tlsv1.2 --tls-max 1.2
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>* Added www.example.com:8443:127.0.0.1 to DNS cache
</span></span><span style=display:flex><span>* Hostname www.example.com was found in DNS cache
</span></span><span style=display:flex><span>*   Trying 127.0.0.1:8443...
</span></span><span style=display:flex><span>* Connected to www.example.com <span style=color:#ce5c00;font-weight:700>(</span>127.0.0.1<span style=color:#ce5c00;font-weight:700>)</span> port <span style=color:#0000cf;font-weight:700>8443</span> <span style=color:#ce5c00;font-weight:700>(</span><span style=color:#8f5902;font-style:italic>#0)</span>
</span></span><span style=display:flex><span>* ALPN: offers h2
</span></span><span style=display:flex><span>* ALPN: offers http/1.1
</span></span><span style=display:flex><span>* Cipher selection: ECDHE-ECDSA-CHACHA20-POLY1305
</span></span><span style=display:flex><span>*  CAfile: example.com.crt
</span></span><span style=display:flex><span>*  CApath: none
</span></span><span style=display:flex><span>* <span style=color:#ce5c00;font-weight:700>(</span>304<span style=color:#ce5c00;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>(</span>OUT<span style=color:#ce5c00;font-weight:700>)</span>, TLS handshake, Client hello <span style=color:#ce5c00;font-weight:700>(</span>1<span style=color:#ce5c00;font-weight:700>)</span>:
</span></span><span style=display:flex><span>* error:1404B410:SSL routines:ST_CONNECT:sslv3 alert handshake failure
</span></span><span style=display:flex><span>* Closing connection <span style=color:#0000cf;font-weight:700>0</span>
</span></span></code></pre></div><p>Moving forward in the doc, we will be configuring the existing Gateway listener to accept both kinds of ciphers.</p><h2 id=tls-certificates-1>TLS Certificates<a class=td-heading-self-link href=#tls-certificates-1 aria-label="Heading self-link"></a></h2><p>Reuse the CA certificate and key pair generated in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#tls-certificates>Secure Gateways</a> task and use this CA to sign both RSA and ECDSA Server certificates.
Note the CA certificate and key names are <code>example.com.crt</code> and <code>example.com.key</code> respectively.</p><p>Create an ECDSA certificate and a private key for <code>www.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl ecparam -noout -genkey -name prime256v1 -out www.example.com.ecdsa.key
</span></span><span style=display:flex><span>openssl req -new -SHA384 -key www.example.com.ecdsa.key -nodes -out www.example.com.ecdsa.csr -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -SHA384  -days <span style=color:#0000cf;font-weight:700>365</span> -in www.example.com.ecdsa.csr -CA example.com.crt -CAkey example.com.key -CAcreateserial -out www.example.com.ecdsa.crt
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert-ecdsa --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.ecdsa.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.ecdsa.crt
</span></span></code></pre></div><p>Patch the Gateway with this additional ECDSA Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/1/tls/certificateRefs/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: example-cert-ecdsa
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><h2 id=testing-1>Testing<a class=td-heading-self-link href=#testing-1 aria-label="Heading self-link"></a></h2><p>Again, while testing in Cluster without External LoadBalancer Support, we can query the example app through Envoy proxy while enforcing an RSA cipher, which should work as it did before:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get  -Isv --ciphers ECDHE-RSA-CHACHA20-POLY1305 --tlsv1.2 --tls-max 1.2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>...
</span></span><span style=display:flex><span>* TLSv1.2 <span style=color:#ce5c00;font-weight:700>(</span>IN<span style=color:#ce5c00;font-weight:700>)</span>, TLS change cipher, Change cipher spec <span style=color:#ce5c00;font-weight:700>(</span>1<span style=color:#ce5c00;font-weight:700>)</span>:
</span></span><span style=display:flex><span>* TLSv1.2 <span style=color:#ce5c00;font-weight:700>(</span>IN<span style=color:#ce5c00;font-weight:700>)</span>, TLS handshake, Finished <span style=color:#ce5c00;font-weight:700>(</span>20<span style=color:#ce5c00;font-weight:700>)</span>:
</span></span><span style=display:flex><span>* SSL connection using TLSv1.2 / ECDHE-RSA-CHACHA20-POLY1305
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>Additionally, querying the example app while enforcing an ECDSA cipher should also work now:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get  -Isv --ciphers ECDHE-ECDSA-CHACHA20-POLY1305 --tlsv1.2 --tls-max 1.2
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>...
</span></span><span style=display:flex><span>* TLSv1.2 <span style=color:#ce5c00;font-weight:700>(</span>IN<span style=color:#ce5c00;font-weight:700>)</span>, TLS change cipher, Change cipher spec <span style=color:#ce5c00;font-weight:700>(</span>1<span style=color:#ce5c00;font-weight:700>)</span>:
</span></span><span style=display:flex><span>* TLSv1.2 <span style=color:#ce5c00;font-weight:700>(</span>IN<span style=color:#ce5c00;font-weight:700>)</span>, TLS handshake, Finished <span style=color:#ce5c00;font-weight:700>(</span>20<span style=color:#ce5c00;font-weight:700>)</span>:
</span></span><span style=display:flex><span>* SSL connection using TLSv1.2 / ECDHE-ECDSA-CHACHA20-POLY1305
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><h1 id=sni-based-certificate-selection>SNI based Certificate selection<a class=td-heading-self-link href=#sni-based-certificate-selection aria-label="Heading self-link"></a></h1><p>This sections gives a walkthrough to generate multiple certificates corresponding to different FQDNs. The same Gateway listener can then be configured to terminate TLS traffic for multiple FQDNs based on the SNI matching.</p><h2 id=prerequisites-2>Prerequisites<a class=td-heading-self-link href=#prerequisites-2 aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><p>Follow the steps in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#tls-certificates>TLS Certificates</a> section to generate self-signed RSA derived Server certificate and private key, and configure those in the Gateway listener configuration to terminate HTTPS traffic.</p><h2 id=additional-configurations>Additional Configurations<a class=td-heading-self-link href=#additional-configurations aria-label="Heading self-link"></a></h2><p>Using the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#tls-certificates>TLS Certificates</a> section, we first generate additional Secret for another Host <code>www.sample.com</code>.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=sample Inc./CN=sample.com&#39;</span> -keyout sample.com.key -out sample.com.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>openssl req -out www.sample.com.csr -newkey rsa:2048 -nodes -keyout www.sample.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.sample.com/O=sample organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA sample.com.crt -CAkey sample.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.sample.com.csr -out www.sample.com.crt
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>kubectl create secret tls sample-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.sample.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.sample.com.crt
</span></span></code></pre></div><p>Note that all occurrences of <code>example.com</code> were just replaced with <code>sample.com</code></p><p>Next we update the <code>Gateway</code> configuration to accommodate the new Certificate which will be used to Terminate TLS traffic:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/1/tls/certificateRefs/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: sample-cert
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><p>Finally, we update the HTTPRoute to route traffic for hostname <code>www.sample.com</code> to the example backend service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch httproute backend --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/hostnames/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value: www.sample.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  &#39;</span>
</span></span></code></pre></div><h2 id=testing-2>Testing<a class=td-heading-self-link href=#testing-2 aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support-1>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support-1 aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 8443:443 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Query the example app through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get -I
</span></span></code></pre></div><p>Similarly, query the sample app through the same Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.sample.com --resolve <span style=color:#4e9a06>&#34;www.sample.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert sample.com.crt https://www.sample.com:8443/get -I
</span></span></code></pre></div><p>Since the multiple certificates are configured on the same Gateway listener, Envoy was able to provide the client with appropriate certificate based on the SNI in the client request.</p><h3 id=clusters-with-external-loadbalancer-support-1>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support-1 aria-label="Heading self-link"></a></h3><p>Refer to the steps mentioned earlier under <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#clusters-with-external-loadbalancer-support>Testing in clusters with External LoadBalancer Support</a></p><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-29400fabdf9ef11ec15d82b0616db296>9 - Threat Model</h1><h1 id=envoy-gateway-threat-model-and-end-user-recommendations>Envoy Gateway Threat Model and End User Recommendations<a class=td-heading-self-link href=#envoy-gateway-threat-model-and-end-user-recommendations aria-label="Heading self-link"></a></h1><h2 id=about>About<a class=td-heading-self-link href=#about aria-label="Heading self-link"></a></h2><p>This work was performed by <a href=https://control-plane.io/>ControlPlane</a> and commissioned by the <a href=https://www.linuxfoundation.org/>Linux Foundation</a>. ControlPlane is a global cloud native and open source cybersecurity consultancy, trusted as the partner of choice in securing: multinational banks; major public clouds; international financial institutions; critical national infrastructure programs; multinational oil and gas companies, healthcare and insurance providers; and global media firms.</p><h2 id=threat-modelling-team>Threat Modelling Team<a class=td-heading-self-link href=#threat-modelling-team aria-label="Heading self-link"></a></h2><p>James Callaghan, Torin van den Bulk, Eduardo Olarte</p><h2 id=reviewers>Reviewers<a class=td-heading-self-link href=#reviewers aria-label="Heading self-link"></a></h2><p>Arko Dasgupta, Matt Turner, Zack Butcher, Marco De Benedictis</p><h2 id=introduction>Introduction<a class=td-heading-self-link href=#introduction aria-label="Heading self-link"></a></h2><p>As we embrace the proliferation of microservice-based architectures in the cloud-native landscape, simplicity in setup and configuration becomes paramount as DevOps teams face the challenge of choosing between numerous similar technologies. One such choice which every team deploying to Kubernetes faces is what to use as an ingress controller. With a plethora of options available, and the existence of vendor-specific annotations leading to small inconsistencies between implementations, the <a href=https://gateway-api.sigs.k8s.io/>Gateway API</a> project was introduced by the SIG-NETWORK community, with the goal of eventually replacing the Ingress resource.</p><p>Envoy Gateway is configured by Gateway API resources, and serves as an intuitive and feature-rich wrapper over the widely acclaimed Envoy Proxy. With a convenient setup based on Kubernetes (K8s) manifests, Envoy Gateway streamlines the management of Envoy Proxy instances in an edge-proxy setting, reducing the operational overhead of managing low-level Envoy configurations. Envoy Gateway benefits cloud-native DevOps teams through its role-oriented configuration, providing granular control based on Role-Based Access Control (RBAC) principles. These features form the basis of our exploration into Envoy Gateway and the rich feature set it brings to the table.</p><p>In this threat model, we aim to provide an analysis of Envoy Gateway&rsquo;s design components and their capabilities (at version 1.0) through a threat-driven approach. It should be noted that this does not constitute a security audit of the Envoy Gateway project, but instead focuses on different possible deployment topologies for Envoy Gateway with the goal of deriving recommendations and best practice guidance for end users.</p><p>The Envoy Gateway project recommends a <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/deployment-mode/#multi-tenancy>multi-tenancy model</a> whereby each tenant deploys their own Envoy Gateway controller in a namespace which they own. We will also explore the implications and risks associated with multiple tenants using a shared controller.</p><h3 id=scope>Scope<a class=td-heading-self-link href=#scope aria-label="Heading self-link"></a></h3><p>The primary focus of this threat model is to identify and assess security risks associated with deploying and operating Envoy Gateway within a multi-tenant Kubernetes (K8s) cluster. This model aims to provide a comprehensive understanding of the system, its transmission points, and potential vulnerabilities to enumerated threats.</p><h3 id=in-scope>In Scope<a class=td-heading-self-link href=#in-scope aria-label="Heading self-link"></a></h3><p><strong>Envoy Gateway</strong>: As the primary focus of this threat model, all aspects of Envoy Gateway, including its configuration, deployment, and operation will be analysed. This includes how the gateway manages TLS certificates, authentication, service-to-service traffic routing, and more.</p><p><strong>Kubernetes Cluster</strong>: Configuration and operation of the underlying Kubernetes cluster, including how it manages network policies, access control, and resource isolation for different namespaces/tenants in relation to Envoy will be considered.</p><p><strong>Tenant Workloads</strong>: Tenant workloads (and the pods they run on) will be considered, focusing on how they interact with the Envoy Gateway and potential vulnerabilities that could be exploited.</p><h4 id=out-of-scope>Out of Scope<a class=td-heading-self-link href=#out-of-scope aria-label="Heading self-link"></a></h4><p>This threat model will not consider security risks associated with the underlying infrastructure (e.g., EC2 compute instances and S3 buckets) or non-Envoy related components within the Kubernetes Cluster. It will focus solely on the Envoy Gateway and its interaction with the Kubernetes cluster and tenant workloads.</p><p>Implementation of Envoy Gateway as an egress traffic controller is out of scope for this threat model and will not be considered in the report&rsquo;s findings.</p><h3 id=related-resources>Related Resources<a class=td-heading-self-link href=#related-resources aria-label="Heading self-link"></a></h3><p><a href=https://blog.envoyproxy.io/introducing-envoy-gateway-ad385cc59532>Introducing Envoy Gateway</a></p><p><a href=https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/security/threat_model#threat-model>Envoy Proxy Threat Model</a></p><p><a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/edge#best-practices-edge>Configuring Envoy as an Edge Proxy</a></p><p><a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/deployment-mode/>Envoy Gateway Deployment Mode</a></p><p><a href=https://gateway-api.sigs.k8s.io/concepts/security-model/>Kubernetes Gateway API Security Model</a></p><h2 id=architecture-overview>Architecture Overview<a class=td-heading-self-link href=#architecture-overview aria-label="Heading self-link"></a></h2><h3 id=summary>Summary<a class=td-heading-self-link href=#summary aria-label="Heading self-link"></a></h3><p>To provide an in-depth look into both the system design and end-user deployment of Envoy Gateway, we will be focusing on the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/threat-model/#deployment-architecture-diagram>Deployment Architecture Diagram</a> below.</p><p>The Deployment Architecture Diagram provides a high-level model of an end-user deployment of Envoy Gateway. For simplicity, we will look at different deployment topologies on a single multi-tenant Kubernetes cluster. Envoy Gateway operates as an edge proxy within this environment, handling the traffic flow between external interfaces and services within the cluster. The example will use two Envoy Gateway controllers - one dedicated controller for a single tenant, and one shared controller for two other tenants. Each Envoy Gateway controller will accept a single GatewayClass resource.</p><h3 id=deployment-architecture-diagram>Deployment Architecture Diagram<a class=td-heading-self-link href=#deployment-architecture-diagram aria-label="Heading self-link"></a></h3><p>As Envoy Gateway implements the <a href=https://gateway-api.sigs.k8s.io/concepts/api-overview/>Kubernetes GatewayAPI</a>, this threat model will focus on the key objects in the Gateway API resource model:</p><ol><li><p><strong>GatewayClass:</strong> defines a set of gateways with a commonconfiguration and behaviour. It is a cluster scoped resource.</p></li><li><p><strong>Gateway:</strong> requests a point where traffic can be translated to Services within the cluster.</p></li><li><p><strong>Routes:</strong> describe how traffic coming via the Gateway maps to theServices.</p></li></ol><p>At the time of writing, Envoy Gateway only supports a Kubernetes provider. As such, we will consider a reference architecture where multiple teams are working on the same Kubernetes cluster within different namespaces (Tenant A, B, & C). We will assume that some teams have similar security and performance needs, and a decision has been made to use a shared Gateway. However, we will also consider the case that some teams require dedicated Gateways, perhaps for compliance reasons or requirements driven by an internal threat model.</p><p>We will consider the following organisational roles, as per the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/>Gateway API security model</a>:</p><ol><li><p><strong>Infrastructure provider</strong>: The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider (AWS, Azure, GCP, &mldr;) or the PaaS provider in a company.</p></li><li><p><strong>Cluster operator</strong>: The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions.</p></li><li><p><strong>Application developer</strong>: The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends).</p></li><li><p><strong>Application admin</strong>: The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole.</p></li></ol><p>Our threat model will be based on the high-level setup shown below, where Envoy is used in an edge-proxy scenario:</p><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/architecture_threat_model.png alt=Architecture></p><p>The following use cases will be considered, in line with the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/quickstart/>Envoy Gateway Tasks</a>:</p><ol><li>Routing and controlling traffic, including:
a. HTTP<br>b. TCP<br>c. UDP<br>d. gRPC<br>e.TLS passthrough</li><li>TLS termination</li><li>Request Authentication</li><li>Rate Limiting</li></ol><h2 id=key-assumptions>Key Assumptions<a class=td-heading-self-link href=#key-assumptions aria-label="Heading self-link"></a></h2><p>This section outlines the foundational premises that shape our analysis and recommendations for the deployment and management of Envoy Gateway within an organisation. The key assumptions are as follows:</p><p><strong>1. Kubernetes Provider</strong>: For the purposes of this analysis, we assume that a K8s provider will be used to host the cluster.</p><p><strong>2. Multi-tenant cluster</strong>: In order to produce a broad set of recommendations, it is assumed that within the single cluster, there is:</p><ul><li><p>A dedicated cluster operation (ops) team responsible for maintaining the core cluster infrastructure.</p></li><li><p>Multiple application teams who wish to define their own Gateway resources, which will route traffic to their respective applications.</p></li></ul><p><strong>3. Soft multi-tenancy model</strong>: It is assumed that co-tenants will have some level of trust between themselves, and will not act in an overtly hostile manner to each other.</p><p><strong>4. Ingress Control</strong>: It&rsquo;s assumed that Envoy Gateway is the only ingress controller in the K8s cluster as multiple controllers can lead to complex routing challenges and introduce out-of-scope security vulnerabilities.</p><p><strong>5. Container Security</strong>: This threat model focuses on evaluating the security of the Envoy Gateway and Envoy Proxy images. All other container images running in tenant clusters, not associated with the edge proxy deployment, are assumed to be secure and obtained from trusted registries such as Docker Hub or Google Container Registry (GCR).</p><p><strong>6. Cloud Provider Security</strong>: It is assumed that the K8s cluster is running on secure cloud infrastructure provided by a trusted Cloud Service Provider (CSP) such as AWS, GCP, or Azure Cloud.</p><h2 id=data>Data<a class=td-heading-self-link href=#data aria-label="Heading self-link"></a></h2><h3 id=data-dictionary>Data Dictionary<a class=td-heading-self-link href=#data-dictionary aria-label="Heading self-link"></a></h3><p>Ultimately, the data of interest in a threat model is the business data processed by the system in question. However, in the case of this threat model, we are looking at a generic deployment architecture involving Envoy Gateway in order to draw out a set of generalised threats which can be considered by teams looking to adopt an implementation of Gateway API. As such, we do not know the business impacts of a compromise of confidentiality, integrity or availability that would typically be captured in a data impact assessment. Instead, will we base our threat assessment on high-level groupings of data structures used in the configuration and operation of the general use cases considered (e.g. HTTP routing, TLS termination, request authentication etc.). We will then assign a confidentiality, integrity and availability impact based on a worst-case scenario of how each compromise could potentially affect business data processed by the generic deployment.</p><table><thead><tr><th>Data Name / Type</th><th>Notes</th><th>Confidentiality</th><th>Integrity</th><th>Availability</th></tr></thead><tbody><tr><td>Static Configuration Data</td><td>Static configuration data is used to configure Envoy Gateway at startup. This data structure allows for a Provider to be set, which Envoy Gateway calls to establish its runtime configuration, resolve services and persist data. Unauthorised modification of static configuration data could enable the Envoy Gateway admin interface to be configured, logging parameters to be modified, global rate limiting configuration to be misconfigured, or malicious extensions registered for the Envoy Gateway Control Plane. A compromise of confidentiality could potentially give an attacker some useful reconnaissance information. A compromise of the availability of this information at startup time would result in Envoy Gateway starting with default parameters.</td><td>Medium</td><td>High</td><td>Low</td></tr><tr><td>Dynamic Configuration Data</td><td>Dynamic configuration data represents the desired state of the Data Plane, and is defined through Envoy Gateway and Gateway API Kubernetes resources. Unauthorised modification of this data could lead to vulnerabilities in an organisation’s Data Plane infrastructure via misconfiguration of an EnvoyProxy custom resource. Misconfiguration of Gateway API objects such as HTTPRoutes or TLSRoutes could result in traffic being directed to incorrect backends. A compromise of confidentiality could potentially give an attacker some useful reconnaissance information. A compromise of the availability of this information could result in tenant application traffic not being routable until the configuration is recovered and reapplied.</td><td>Medium</td><td>High</td><td>Medium</td></tr><tr><td>TLS Private Keys</td><td>TLS Private Keys, typically in PEM format, are used to initiate secure connections and encrypt communications. In the context of this threat model, private keys will be associated with the server side of an inbound TLS connection being terminated at a secure gateway configured through Envoy Gateway. Unauthorised exposure could lead to security threats such as person-in-the-middle attacks, whereby the confidentiality or integrity of business data could be compromised. A compromise of integrity may lead to similar consequences if an attacker could insert their own key material. An availability compromise could lead to tenant services being unavailable until new key material is generated and an appropriate CSR submitted.</td><td>High</td><td>High</td><td>Medium</td></tr><tr><td>TLS Certificates</td><td>X.509 certificates represent the binding of a public key (associated with the private key described above) to an identity in a TLS handshake. If an attacker could compromise the integrity of a certificate, they may be able to bind the identity of a TLS termination point to a key pair under their control, enabling person-in-the middle attacks. An availability compromise could lead to tenant services being unavailable until new key material is generated and an appropriate CSR submitted.</td><td>Low</td><td>High</td><td>Medium</td></tr><tr><td>JWKs</td><td>JWK (JSON Web Key) containing a public key used to validate JWTs for the client authentication use case considered in this threat model. If an attacker could compromise the integrity of a JWK or JSON web key set (JWKS), they could potentially authenticate to a service maliciously. Unavailability of an endpoint exposing JWKs could lead to client requests which require authentication being denied.</td><td>Low</td><td>High</td><td>Medium</td></tr><tr><td>JWTs</td><td>JWTs, formatted as compact, URL-safe JSON data structures, are utilised for the client authentication use case considered in this threat model. Maintaining their confidentiality and integrity is vital to prevent unauthorised access and ensure correct user identification.</td><td>High</td><td>High</td><td>Low</td></tr><tr><td>OIDC credentials</td><td>In OIDC authentication scenarios, the application credentials are represented by a client ID and a client secret. A compromise of its confidentiality or integrity could allow malicious actors to impersonate the application, potentially being able to access resources on behalf of the application and request ID tokens on behalf of users. Unavailability of this data would produce a rejection of the requests coming from legitimate users.</td><td>High</td><td>High</td><td>Medium</td></tr><tr><td>Basic authentiation password hashes</td><td>In basic authentication scenarios, passwords are stored as Kubernetes secrets in <a href=https://httpd.apache.org/docs/current/programs/htpasswd.html>htpasswd</a> format, where each entry is formed by the username and the hashed password. A compromise of these credentials&rsquo; confidentiality and integrity could lead to unauthorised access to the application. Unavailability of these credentials will cause login failures from the application users.</td><td>High</td><td>High</td><td>Medium</td></tr></tbody></table><h3 id=cia-impact-assessment>CIA Impact Assessment<a class=td-heading-self-link href=#cia-impact-assessment aria-label="Heading self-link"></a></h3><table><thead><tr><th>Priority</th><th>Description</th></tr></thead><tbody><tr><td><strong>Confidentiality</strong></td><td></td></tr><tr><td>High</td><td>Compromise of sensitive client data</td></tr><tr><td>Medium</td><td>Information leaked which could be useful for attacker reconnaissance</td></tr><tr><td>Low</td><td>Non-sensitive information leakage</td></tr><tr><td><strong>Integrity</strong></td><td></td></tr><tr><td>High</td><td>Compromise of source code repositories and gateway deployments</td></tr><tr><td>Medium</td><td>Traffic routing fails due to misconfiguration / invalid configuration</td></tr><tr><td>Low</td><td>Non-critical operation is blocked due to misconfiguration / invalid configuration</td></tr><tr><td><strong>Availability</strong></td><td></td></tr><tr><td>High</td><td>Large scale DoS</td></tr><tr><td>Medium</td><td>Tenant application is blocked for a significant period</td></tr><tr><td>Low</td><td>Tenant application is blocked for a short period</td></tr></tbody></table><h3 id=data-flow-diagrams>Data Flow Diagrams<a class=td-heading-self-link href=#data-flow-diagrams aria-label="Heading self-link"></a></h3><p>The Data Flow Diagrams (DFDs) below describe the flow of data between the various processes, entities and data stores in a system, as well as the trust boundaries between different user roles and network interfaces. The DFDs are drawn at two different levels, starting at L0 (high-level system view) and increasing in granularity (to L1).</p><h3 id=dfd-l0>DFD L0<a class=td-heading-self-link href=#dfd-l0 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/DFDL0.png alt="DFD L0"></p><h3 id=dfd-l1>DFD L1<a class=td-heading-self-link href=#dfd-l1 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/DFDL1.png alt="DFD L1"></p><h2 id=key-threats-and-recommendations>Key Threats and Recommendations<a class=td-heading-self-link href=#key-threats-and-recommendations aria-label="Heading self-link"></a></h2><p>The scope of this threat model led to us categorising threats into priorities of High, Medium or Low; notably in a production implementation some of the threats&rsquo; prioritisation may be upgraded or downgraded depending on the business context and data classification.</p><h3 id=risk-vs-threat>Risk vs. Threat<a class=td-heading-self-link href=#risk-vs-threat aria-label="Heading self-link"></a></h3><p>For every finding, the risk and threat are stated. Risk defines the potential for negative outcome while threat defines the event that causes the negative outcome.</p><h3 id=threat-categorization>Threat Categorization<a class=td-heading-self-link href=#threat-categorization aria-label="Heading self-link"></a></h3><p>Throughout this threat model, we categorised threats into different areas based on their origin and the segment of the system that they impact. Here&rsquo;s an overview of each category:</p><p><strong>Container Security (CS)</strong>: These threats are general to containerised applications. Therefore, they are not associated with Envoy Gateway or the Gateway API and could occur in most containerised workloads. They can originate from misconfigurations or vulnerabilities in the orchestrator or the container.</p><p><strong>Gateway API (GW)</strong>: These are threats related to the Gateway API that could affect any of its implementations. Malicious actors could benefit from misconfigurations or excessive permissions on the Gateway API resources (e.g. xRoutes or Gateways) to compromise the confidentiality, integrity, or availability of the application.</p><p><strong>Envoy Gateway (EG)</strong>: These threats are associated with specific configurations or features from Envoy Gateway or Envoy Proxy. If not set properly, these features could be leveraged to gain unauthorised access to protected resources.</p><h3 id=threat-actors>Threat Actors<a class=td-heading-self-link href=#threat-actors aria-label="Heading self-link"></a></h3><p>In order to provide a realistic set of threats that is applicable to most organisations, we de-scoped the most advanced and hard to mitigate threat actors as described below:</p><h4 id=in-scope-threat-actors>In Scope Threat Actors<a class=td-heading-self-link href=#in-scope-threat-actors aria-label="Heading self-link"></a></h4><p>When considering internal threat actors, we chose to follow the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/>security model</a> of the Kubernetes Gateway API.</p><h5 id=internal-attacker>Internal Attacker<a class=td-heading-self-link href=#internal-attacker aria-label="Heading self-link"></a></h5><ul><li><p>Cluster Operator: The cluster operator (ops) is responsible for administration of entire clusters. They manage policies, network access, application permissions.</p></li><li><p>Application Developer: The application developer (dev) is responsible for defining their application configuration (e.g. timeouts, request matching/filter) and Service composition (e.g. path routing to backends).</p></li><li><p>Application Administrator: The application admin has administrative access to some namespaces within a cluster, but not the cluster as a whole.</p></li></ul><h5 id=external-attacker>External Attacker<a class=td-heading-self-link href=#external-attacker aria-label="Heading self-link"></a></h5><ul><li><p>Vandal: Script kiddie, trespasser</p></li><li><p>Motivated Individual: Political activist, thief, terrorist</p></li><li><p>Organised Crime: Syndicates, state-affiliated groups</p></li></ul><h4 id=out-of-scope-threat-actors>Out of Scope Threat Actors<a class=td-heading-self-link href=#out-of-scope-threat-actors aria-label="Heading self-link"></a></h4><h5 id=external-actors>External Actors<a class=td-heading-self-link href=#external-actors aria-label="Heading self-link"></a></h5><ul><li><p>Infrastructure Provider: The infrastructure provider (infra) is responsible for the overall environment that the cluster(s) are operating in. Examples include: the cloud provider, or the PaaS provider in a company.</p></li><li><p>Cloud Service Insider: Employee, external contractor, temporary worker</p></li><li><p>Foreign Intelligence Services (FIS): Nation states</p></li></ul><h2 id=high-priority-findings>High Priority Findings<a class=td-heading-self-link href=#high-priority-findings aria-label="Heading self-link"></a></h2><h3 id=egtm-001-usage-of-self-signed-certificates>EGTM-001 Usage of self-signed certificates<a class=td-heading-self-link href=#egtm-001-usage-of-self-signed-certificates aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-001</td><td>EGTM-GW-001</td><td>Gateway API</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: Self-signed certificates (which do not comply with PKI best practices) could lead to unauthorised access to the private key associated with the certificate used for inbound TLS termination at Envoy Proxy, compromising the confidentiality and integrity of proxied traffic.</p><p><strong>Threat</strong>: Compromise of the private key associated with the certificate used for inbound TLS terminating at Envoy Proxy.</p><p><strong>Recommendation</strong>: The Envoy Gateway quickstart demonstrates how to set up a Secure Gateway using an example where a self-signed root certificate is created using openssl. As stated in the Envoy Gateway documentation, this is not a suitable configuration for Production usage. It is recommended that PKI best practices are followed, whereby certificates are signed by an Intermediary CA which sits underneath an organisational 'offline' Root CA.</p><p>PKI best practices should also apply to the management of client certificates when using mTLS. The Envoy Gateway <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/mutual-tls/>mTLS</a> guide shows how to set up client certificates using self-signed certificates. In the same way as gateway certificates and, as mentioned in the documentation, this configuration should not be used in production environments.</p><h3 id=egtm-002-private-keys-are-stored-as-kubernetes-secrets>EGTM-002 Private keys are stored as Kubernetes secrets<a class=td-heading-self-link href=#egtm-002-private-keys-are-stored-as-kubernetes-secrets aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-002</td><td>EGTM-CS-001</td><td>Container Security</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor could compromise the Kubernetes secret containing the Envoy private key, allowing the attacker to decrypt Envoy Proxy traffic, compromising the confidentiality of proxied traffic.</p><p><strong>Threat</strong>: Kubernetes secret containing the Envoy private key is compromised and used to decrypt proxied traffic.</p><p><strong>Recommendation</strong>: Certificate management best practices mandate short-lived key material where practical, meaning that a mechanism for rotation of private keys and certificates is required, along with a way for certificates to be mounted into Envoy containers. If Kubernetes secrets are used, when a certificate expires, the associated secret must be updated, and Envoy containers must be redeployed. Instead of a manual configuration, it is recommended that <a href=https://github.com/cert-manager/cert-manager>cert-manager</a> is used.</p><h3 id=egtm-004-usage-of-clusterroles-with-wide-permissions>EGTM-004 Usage of ClusterRoles with wide permissions<a class=td-heading-self-link href=#egtm-004-usage-of-clusterroles-with-wide-permissions aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-004</td><td>EGTM-K8-002</td><td>Container Security</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor could abuse misconfigured RBAC to access the Envoy Gateway ClusterRole (envoy-gateway-role) and use it to expose all secrets across the cluster, thus compromising the confidentiality and integrity of tenant data.</p><p><strong>Threat</strong>: Compromised Envoy Gateway or misconfigured ClusterRoleBinding (envoy-gateway-rolebinding) to Envoy Gateway ClusterRole (envoy-gateway-role), provides access to resources and secrets in different namespaces.</p><p><strong>Recommendation</strong>: Users should be aware that Envoy Gateway uses a ClusterRole (envoy-gateway-role) when deployed via the Helm chart, to allow management of Envoy Proxies across different namespaces. This ClusterRole is powerful and includes the ability to read secrets in namespaces which may not be within the purview of Envoy Gateway.</p><p>Kubernetes best-practices involve restriction of ClusterRoleBindings, with the use of RoleBindings where possible to limit access per namespace by specifying the namespace in metadata. Namespace isolation reduces the impact of compromise from cluster-scoped roles. Ideally, fine-grained K8s roles should be created per the principle of least privilege to ensure they have the minimum access necessary for role functions.</p><p>The pull request #<a href=https://github.com/envoyproxy/gateway/pull/1656>1656</a> introduced the use of Roles and RoleBindings in <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#kuberneteswatchmode>namespaced mode</a>. This feature can be leveraged to reduce the amount of permissions required by the Envoy Gateway.</p><h3 id=egtm-007-misconfiguration-of-envoy-gateway-dynamic-config>EGTM-007 Misconfiguration of Envoy Gateway dynamic config<a class=td-heading-self-link href=#egtm-007-misconfiguration-of-envoy-gateway-dynamic-config aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-007</td><td>EGTM-EG-002</td><td>Envoy Gateway</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor could exploit misconfigured Kubernetes RBAC to create or modify Gateway API resources with no business need, potentially leading to the compromise of the confidentiality, integrity, and availability of resources and traffic within the cluster.</p><p><strong>Threat</strong>: Unauthorised creation or misconfiguration of Gateway API resources by a threat actor with cluster-scoped access.</p><p><strong>Recommendation</strong>: Configure the apiGroup and resource fields in RBAC policies to restrict access to <a href=https://gateway-api.sigs.k8s.io/>Gateway</a> and <a href=https://gateway-api.sigs.k8s.io/api-types/gatewayclass/>GatewayClass</a> resources. Enable namespace isolation by using the namespace field, preventing unauthorised access to gateways in other namespaces.</p><h3 id=egtm-009-co-tenant-misconfigures-resource-across-namespaces>EGTM-009 Co-tenant misconfigures resource across namespaces<a class=td-heading-self-link href=#egtm-009-co-tenant-misconfigures-resource-across-namespaces aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-009</td><td>EGTM-GW-002</td><td>Gateway API</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a co-tenant misconfigures Gateway or Route resources, compromising the confidentiality, integrity, and availability of routed traffic through Envoy Gateway.</p><p><strong>Threat</strong>: Malicious or accidental co-tenant misconfiguration of Gateways and Routes associated with other application teams.</p><p><strong>Recommendation</strong>: Dedicated Envoy Gateways should be provided to each tenant within their respective namespace. A one-to-one relationship should be established between GatewayClass and Gateway resources, meaning that each tenant namespace should have their own GatewayClass watched by a unique Envoy Gateway Controller as defined here in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/deployment-mode/>Deployment Mode</a> documentation.</p><p>Application Admins should have write permissions on the Gateway resource, but only in their specific namespaces, and Application Developers should only hold write permissions on Route resources. To enact this access control schema, follow the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#write-permissions-for-advanced-4-tier-model>Write Permissions for Advanced 4 Tier Model</a> described in the Kubernetes Gateway API security model. Examples of secured gateway-route topologies can be found <a href=https://gateway-api.sigs.k8s.io/concepts/api-overview/#attaching-routes-to-gateways>here</a> within the Kubernetes Gateway API docs.</p><p>Optionally, consider a GitOps model, where only the GitOps operator has the permission to deploy or modify custom resources in production.</p><h3 id=egtm-014-malicious-image-admission>EGTM-014 Malicious image admission<a class=td-heading-self-link href=#egtm-014-malicious-image-admission aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-014</td><td>EGTM-CS-006</td><td>Container Security</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a supply chain attack on Envoy Gateway results in an arbitrary compromise of the confidentiality, integrity or availability of tenant data.</p><p><strong>Threat</strong>: Supply chain threat actor introduces malicious code into Envoy Gateway or Proxy.</p><p><strong>Recommendation</strong>: The Envoy Gateway project should continue to work towards conformance with supply-chain security best practices throughout the project lifecycle (for example, as set out in the <a href=https://github.com/cncf/tag-security/blob/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf>CNCF Software Supply Chain Best Practices Whitepaper</a>). Adherence to <a href=https://slsa.dev/>Supply-chain Levels for Software Artefacts</a> (SLSA) standards is crucial for maintaining the security of the system. Employ version control systems to monitor the source and build platforms and assign responsibility to a specific stakeholder.</p><p>Integrate a supply chain security tool such as Sigstore, which provides native capabilities for signing and verifying container images and software artefacts. <a href=https://www.cisa.gov/sbom>Software Bill of Materials</a> (SBOM), <a href=https://www.ntia.gov/files/ntia/publications/vex_one-page_summary.pdf>Vulnerability Exploitability eXchange</a> (VEX), and signed artefacts should also be incorporated into the security protocol.</p><h3 id=egtm-020-out-of-date-or-misconfigured-envoy-proxy-image>EGTM-020 Out of date or misconfigured Envoy Proxy image<a class=td-heading-self-link href=#egtm-020-out-of-date-or-misconfigured-envoy-proxy-image aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-020</td><td>EGTM-CS-009</td><td>Container Security</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor exploits an Envoy Proxy vulnerability to remote code execution (RCE) due to out of date or misconfigured Envoy Proxy pod deployment, compromising the confidentiality and integrity of Envoy Proxy along with the availability of the proxy service.</p><p><strong>Threat</strong>: Deployment of an Envoy Proxy or Gateway image containing exploitable CVEs.</p><p><strong>Recommendation</strong>: Always use the latest version of the Envoy Proxy image. Regularly check for updates and patch the system as soon as updates become available. Implement a CI/CD pipeline that includes security checks for images and prevents deployment of insecure configurations. A suitable tool should be chosen to provide container vulnerability scanning to mitigate the risk of known vulnerabilities.</p><p>Utilise the <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/>Pod Security Admission</a> controller to enforce <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a> and configure the <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>pod security context</a> to limit its capabilities per the principle of least privilege.</p><h3 id=egtm-022-credentials-are-stored-as-kubernetes-secrets>EGTM-022 Credentials are stored as Kubernetes Secrets<a class=td-heading-self-link href=#egtm-022-credentials-are-stored-as-kubernetes-secrets aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-022</td><td>EGTM-CS-010</td><td>Container Security</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that the OIDC client secret (for OIDC authentication) and user password hashes (for basic authentication) get leaked due to misconfigured RBAC permissions.</p><p><strong>Threat</strong>: Unauthorised access to the application due to credential leakage.</p><p><strong>Recommendation</strong>: Ensure that only authorised users and service accounts are able to access secrets. This is especially important in namespaces where SecurityPolicy objects are configured, since those namespaces are the ones to store secrets containing the client secret (in OIDC scenarios) and user password hashes (in basic authentication scenarios).</p><p>To do so, minimise the use of ClusterRoles and Roles allowing listing and getting secrets. Perform periodic audits of RBAC permissions.</p><h3 id=egtm-023-weak-authentication>EGTM-023 Weak Authentication<a class=td-heading-self-link href=#egtm-023-weak-authentication aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-023</td><td>EGTM-EG-007</td><td>Envoy Gateway</td><td>High</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk of unauthorised access due to the use of basic authentication, which does not enforce any password restriction in terms of complexity and length. In addition, password hashes are stored in SHA1 format, which is a deprecated hashing function.</p><p><strong>Threat</strong>: Unauthorised access to the application due to weak authentication mechanisms.</p><p><strong>Recommendation</strong>: It is recommended to make use of stronger authentication mechanisms (i.e. JWT authentication and OIDC authentication) instead of basic authentication. These authentication mechanisms have many advantages, such as the use of short-lived credentials and a central management of security policies through the identity provider.</p><h2 id=medium-priority-findings>Medium Priority Findings<a class=td-heading-self-link href=#medium-priority-findings aria-label="Heading self-link"></a></h2><h3 id=egtm-008-misconfiguration-of-envoy-gateway-static-config>EGTM-008 Misconfiguration of Envoy Gateway static config<a class=td-heading-self-link href=#egtm-008-misconfiguration-of-envoy-gateway-static-config aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-008</td><td>EGTM-EG-003</td><td>Envoy Gateway</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk of a threat actor misconfiguring static config and compromising the integrity of Envoy Gateway, ultimately leading to the compromised confidentiality, integrity, or availability of tenant data and cluster resources.</p><p><strong>Threat</strong>: Accidental or deliberate misconfiguration of static configuration leads to a misconfigured deployment of Envoy Gateway, for example logging parameters could be modified or global rate limiting configuration misconfigured.</p><p><strong>Recommendation</strong>: Implement a GitOps model, utilising Kubernetes' Role-Based Access Control (RBAC) and adhering to the principle of least privilege to minimise human intervention on the cluster. For instance, tools like <a href=https://fluxcd.io/>Flux</a> and <a href=https://argo-cd.readthedocs.io/en/stable/>ArgoCD</a> can be used for declarative GitOps deployments, ensuring all changes are tracked and reviewed. Additionally, configure your source control management (SCM) system to include mandatory pull request (PR) reviews, commit signing, and protected branches to ensure only authorised changes can be committed to the start-up configuration.</p><h3 id=egtm-010-weak-pod-security-contexts-and-policies>EGTM-010 Weak pod security contexts and policies<a class=td-heading-self-link href=#egtm-010-weak-pod-security-contexts-and-policies aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-010</td><td>EGTM-CS-005</td><td>Container Security</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor exploits a weak pod security context, compromising the CIA of a node and the resources / services which run on it.</p><p><strong>Threat</strong>: Threat Actor who has compromised a pod exploits weak security context to escape to a node, potentially leading to the compromise of Envoy Proxy or Gateway running on the same node.</p><p><strong>Recommendation</strong>: To mitigate this risk, apply <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a> at a minimum of <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/#baseline>Baseline</a> level to all namespaces, especially those containing Envoy Gateway and Proxy Pods. Pod security standards are implemented through K8s <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/>Pod Security Admission</a> to provide <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces>admission control modes</a> (enforce, audit, and warn) for namespaces. Pod security standards can be enforced by namespace labels as shown <a href=https://kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/>here</a>, to enforce a baseline level of pod security to specific namespaces.</p><p>Further enhance the security by implementing a sandboxing solution such as <a href=https://gvisor.dev/>gVisor</a> for Envoy Gateway and Proxy Pods to isolate the application from the host kernel. This can be set within the runtimeClassName of the Pod specification.</p><h3 id=egtm-012-clusterroles-and-roles-with-permission-to-deploy-referencegrants>EGTM-012 ClusterRoles and Roles with permission to deploy ReferenceGrants<a class=td-heading-self-link href=#egtm-012-clusterroles-and-roles-with-permission-to-deploy-referencegrants aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-012</td><td>EGTM-GW-004</td><td>Gateway API</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor could abuse excessive RBAC privileges to create ReferenceGrant resources. These resources could then be used to create cross-namespace communication, leading to unauthorised access to the application. This could compromise the confidentiality and integrity of resources and configuration in the affected namespaces and potentially disrupt the availability of services that rely on these object references.</p><p><strong>Threat</strong>: A ReferenceGrant is created, which validates traffic to cross namespace trust boundaries without a valid business reason, such as a route in one tenant's namespace referencing a backend in another.</p><p><strong>Recommendation</strong>: Ensure that the ability to create ReferenceGrant resources is restricted to the minimum number of people. Pay special attention to ClusterRoles that allow that action.</p><h3 id=egtm-018-network-denial-of-service-dos>EGTM-018 Network Denial of Service (DoS)<a class=td-heading-self-link href=#egtm-018-network-denial-of-service-dos aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-018</td><td>EGTM-GW-006</td><td>Gateway API</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that malicious requests could lead to a Denial of Service (DoS) attack, thereby reducing API gateway availability due to misconfigurations in rate-limiting or load balancing controls, or a lack of route timeout enforcement.</p><p><strong>Threat</strong>: Reduced API gateway availability due to an attacker's maliciously crafted request (e.g., QoD) potentially inducing a Denial of Service (DoS) attack.</p><p><strong>Recommendation</strong>: To ensure high availability and to mitigate potential security threats, adhere to the Envoy Gateway documentation for the configuration of a <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/traffic/global-rate-limit/>rate-limiting</a> filter and load balancing.</p><p>Further, adhere to best practices for configuring Envoy Proxy as an edge proxy documented <a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/edge#configuring-envoy-as-an-edge-proxy>here</a> within the EnvoyProxy docs. This involves configuring TCP and HTTP proxies with specific settings, including restricting access to the admin endpoint, setting the <a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/operations/overload_manager/overload_manager#config-overload-manager>overload manager</a> and <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-per-connection-buffer-limit-bytes>listener</a> / <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-per-connection-buffer-limit-bytes>cluster</a> buffer limits, enabling <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-use-remote-address>use_remote_address</a>, setting <a href=https://www.envoyproxy.io/docs/envoy/latest/faq/configuration/timeouts#faq-configuration-timeouts>connection and stream timeouts</a>, limiting <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-http2protocoloptions-max-concurrent-streams>maximum concurrent streams</a>, setting <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-http2protocoloptions-initial-stream-window-size>initial stream window size limit</a>, and configuring action on <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-headers-with-underscores-action>headers_with_underscores</a>.</p><p><a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path>Path normalisation</a> should be enabled to minimise path confusion vulnerabilities. These measures help protect against volumetric threats such as Denial of Service (DoS) attacks. Utilise custom resources to implement policy attachment, thereby exposing request limit configuration for route types.</p><h3 id=egtm-019-jwt-based-authentication-replay-attacks>EGTM-019 JWT-based authentication replay attacks<a class=td-heading-self-link href=#egtm-019-jwt-based-authentication-replay-attacks aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-019</td><td>EGTM-DP-004</td><td>Container Security</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that replay attacks using stolen or reused JSON Web Tokens (JWTs) can compromise transmission integrity, thereby undermining the confidentiality and integrity of the data plane.</p><p><strong>Threat</strong>: Transmission integrity is compromised due to replay attacks using stolen or reused JSON Web Tokens (JWTs).</p><p><strong>Recommendation</strong>: Comply with JWT best practices for enhanced security, paying special attention to the use of short-lived tokens, which reduce the window of opportunity for a replay attack. The <a href=https://datatracker.ietf.org/doc/html/rfc7519#page-9>exp</a> claim can be used to set token expiration times.</p><h3 id=egtm-024-excessive-privileges-via-extension-policies>EGTM-024 Excessive privileges via extension policies<a class=td-heading-self-link href=#egtm-024-excessive-privileges-via-extension-policies aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-024</td><td>EGTM-EG-008</td><td>Envoy Gateway</td><td>Medium</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk of developers getting more privileges than required due to the use of SecurityPolicy, ClientTrafficPolicy, EnvoyPatchPolicy and BackendTrafficPolicy. These resources can be attached to a Gateway resource. Therefore, a developer with permission to deploy them would be able to modify a Gateway configuration by targeting the gateway in the policy manifest. This conflicts with the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#write-permissions-for-advanced-4-tier-model>Advanced 4 Tier Model</a>, where developers do not have write permissions on Gateways.</p><p><strong>Threat</strong>: Excessive developer permissions lead to a misconfiguration and/or unauthorised access.</p><p><strong>Recommendation</strong>: Considering the Tenant C scenario (represented in the Architecture Diagram), if a developer can create SecurityPolicy, ClientTrafficPolicy, EnvoyPatchPolicy or BackendTrafficPolicy objects in namespace C, they would be able to modify a Gateway configuration by attaching the policy to the gateway. In such scenarios, it is recommended to either:</p><p>a. Create a separate namespace, where developers have no permissions, to host tenant C's gateway. Note that, due to design decisions, the SecurityPolicy/EnvoyPatchPolicy/ClientTrafficPolicy/BackendTrafficPolicy object can only target resources deployed in the same namespace. Therefore, having a separate namespace for the gateway would prevent developers from attaching the policy to the gateway.</p><p>b. Forbid the creation of these policies for developers in namespace C.</p><p>On the other hand, in scenarios similar to tenants A and B, where a shared gateway namespace is in place, this issue is more limited. Note that in this scenario, developers don't have access to the shared gateway namespace.</p><p>In addition, it is important to mention that EnvoyPatchPolicy resources can also be attached to GatewayClass resources. This means that, in order to comply with the Advanced 4 Tier model, individuals with the Application Administrator role should not have access to this resource either.</p><h2 id=low-priority-findings>Low Priority Findings<a class=td-heading-self-link href=#low-priority-findings aria-label="Heading self-link"></a></h2><h3 id=egtm-003-misconfiguration-leads-to-insecure-tls-settings>EGTM-003 Misconfiguration leads to insecure TLS settings<a class=td-heading-self-link href=#egtm-003-misconfiguration-leads-to-insecure-tls-settings aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-003</td><td>EGTM-EG-001</td><td>Envoy Gateway</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor could downgrade the security of proxied connections by configuring a weak set of cipher suites, compromising the confidentiality and integrity of proxied traffic.</p><p><strong>Threat</strong>: Exploit weak cipher suite configuration to downgrade security of proxied connections.</p><p><strong>Recommendation</strong>: Users operating in highly regulated environments may need to tightly control the TLS protocol and associated cipher suites, blocking non-conforming incoming connections to the gateway.</p><p>EnvoyProxy bootstrap config can be customised as per the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/customize-envoyproxy/>customise EnvoyProxy</a> documentation. In addition, from v.1.0.0, it is possible to configure common TLS properties for a Gateway or XRoute through the <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#clienttrafficpolicy>ClientTrafficPolicy</a> object.</p><h3 id=egtm-005-envoy-gateway-helm-chart-deployment-does-not-set-apparmor-and-seccomp-profiles>EGTM-005 Envoy Gateway Helm chart deployment does not set AppArmor and Seccomp profiles<a class=td-heading-self-link href=#egtm-005-envoy-gateway-helm-chart-deployment-does-not-set-apparmor-and-seccomp-profiles aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-005</td><td>EGTM-CP-002</td><td>Container Security</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: Threat actor who has obtained access to Envoy Gateway pod could exploit the lack of AppArmor and Seccomp profiles in the Envoy Gateway deployment to attempt a container breakout, given the presence of an exploitable vulnerability, potentially impacting the confidentiality and integrity node resources.</p><p><strong>Threat</strong>: Unauthorised syscalls and malicious code running in the Envoy Gateway pod.</p><p><strong>Recommendation</strong>: Implement <a href=https://kubernetes.io/docs/tutorials/security/apparmor/>AppArmor</a> policies by setting &lt;container_name>: &lt;profile_ref> within container.apparmor.security.beta.kubernetes.io (note, this config is set <em>per container</em>). Well-defined AppArmor policies may provide greater protection from unknown threats.</p><p>Enforce <a href=https://kubernetes.io/docs/tutorials/security/seccomp/>Seccomp</a> profiles by setting the seccompProfile under securityContext. Ideally, a <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#create-pod-with-a-seccomp-profile-that-only-allows-necessary-syscalls>fine-grained</a> profile should be used to restrict access to only necessary syscalls, however the --seccomp-default flag can be set to resort to <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#create-pod-that-uses-the-container-runtime-default-seccomp-profile>RuntimeDefault</a> which provides a container runtime specific. Example seccomp profiles can be found <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#download-profiles>here</a>.</p><p>To further enhance pod security, consider implementing <a href=https://en.wikipedia.org/wiki/Security-Enhanced_Linux>SELinux</a> via seLinuxOptions for additional syscall attack surface reduction. Setting readOnlyRootFilesystem == true enforces an immutable root filesystem, preventing the addition of malicious binaries to the PATH and increasing the attack cost. Together, these configuration items improve the pods <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>Security Context</a>.</p><h3 id=egtm-006-envoy-proxy-pods-deployed-with-a-shell-enabled>EGTM-006 Envoy Proxy pods deployed with a shell enabled<a class=td-heading-self-link href=#egtm-006-envoy-proxy-pods-deployed-with-a-shell-enabled aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-006</td><td>EGTM-CS-004</td><td>Container Security</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a threat actor exploits a vulnerability in Envoy Proxy to expose a reverse shell, enabling them to compromise the confidentiality, integrity and availability of tenant data via a secondary attack.</p><p><strong>Threat</strong>: If an external attacker managed to exploit a vulnerability in Envoy, the presence of a shell would be greatly helpful for the attacker in terms of potentially pivoting, escalating, or establishing some form of persistence.</p><p><strong>Recommendation</strong>: By default, Envoy uses a <a href=https://github.com/GoogleContainerTools/distroless>distroless</a> image since v.0.6.0, which does not ship a shell. Therefore, ensure EnvoyProxy image is up-to-date and patched with the latest stable version.</p><p>If using private EnvoyProxy images, use a lightweight EnvoyProxy image without a shell or debugging tool(s) which may be useful for an attacker.</p><p>An <a href=https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/#audit-policy>AuditPolicy</a> (audit.k8s.io/v1beta1) can be configured to record API calls made within your cluster, allowing for identification of malicious traffic and enabling incident response. Requests are recorded based on stages which delineate between the lifecycle stage of the request made (e.g., RequestReceived, ResponseStarted, & ResponseComplete).</p><h3 id=egtm-011-route-bindings-on-custom-labels>EGTM-011 Route Bindings on custom labels<a class=td-heading-self-link href=#egtm-011-route-bindings-on-custom-labels aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-011</td><td>EGTM-GW-003</td><td>Gateway API</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that a gateway owner (or someone with the ability to set namespace labels) maliciously or accidentally binds routes across namespace boundaries, potentially compromising the confidentiality and integrity of traffic in a multitenant scenario.</p><p><strong>Threat</strong>: If a Route Binding within a Gateway Listener is configured based on a custom label, it could allow a malicious internal actor with the ability to label namespaces to change the set of namespaces supported by the Gateway.</p><p><strong>Recommendation</strong>: Consider the use of custom admission control to restrict what labels can be set on namespaces through tooling such as <a href=https://kyverno.io/policies/pod-security/>Kubewarden</a>, <a href=https://github.com/kubewarden>Kyverno</a>, and <a href=https://github.com/open-policy-agent/gatekeeper>OPA Gatekeeper</a>. Route binding should follow the Kubernetes Gateway API security model, as shown <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#1-route-binding>here</a>, to connect gateways in different namespaces.</p><h3 id=egtm-013-gatewayclass-namespace-validation-is-not-configured>EGTM-013 GatewayClass namespace validation is not configured<a class=td-heading-self-link href=#egtm-013-gatewayclass-namespace-validation-is-not-configured aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-013</td><td>EGTM-GW-005</td><td>Gateway API</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that an unauthorised actor deploys an unauthorised GatewayClass due to GatewayClass namespace validation not being configured, leading to non-compliance with business and security requirements.</p><p><strong>Threat</strong>: Unauthorised deployment of Gateway resource via GatewayClass template which crosses namespace trust boundaries.</p><p><strong>Recommendation</strong>: Leverage GatewayClass namespace validation to limit the namespaces where GatewayClasses can be run through a tool such as <a href=https://github.com/open-policy-agent/gatekeeper>OPA Gatekeeper</a>. Reference pull request #<a href=https://github.com/open-policy-agent/gatekeeper-library/pull/24>24</a> within gatekeeper-library which outlines how to add GatewayClass namespace validation through a GatewayClassNamespaces API resource kind within the constraints.gatekeeper.sh/v1beta1 apiGroup.</p><h3 id=egtm-015-serviceaccount-token-authentication>EGTM-015 ServiceAccount token authentication<a class=td-heading-self-link href=#egtm-015-serviceaccount-token-authentication aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-015</td><td>EGTM-CS-007</td><td>Container Security</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that threat actors could exploit ServiceAccount tokens for illegitimate authentication, thereby leading to privilege escalation and the undermining of gateway API resources' integrity, confidentiality, and availability.</p><p><strong>Threat</strong>: The threat arises from threat actors impersonating the envoy-gateway ServiceAccount through the replay of ServiceAccount tokens, thereby achieving escalated privileges and gaining unauthorised access to Kubernetes resources.</p><p><strong>Recommendation</strong>: Limit the creation of ServiceAccounts to only when necessary, specifically refraining from using default service account tokens, especially for high-privilege service accounts. For legacy clusters running Kubernetes version 1.21 or earlier, note that ServiceAccount tokens are long-lived by default. To disable the automatic mounting of the service account token, set automountServiceAccountToken: false in the PodSpec.</p><h3 id=egtm-016-misconfiguration-leads-to-lack-of-envoy-proxy-access-activity-visibility>EGTM-016 Misconfiguration leads to lack of Envoy Proxy access activity visibility<a class=td-heading-self-link href=#egtm-016-misconfiguration-leads-to-lack-of-envoy-proxy-access-activity-visibility aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-016</td><td>EGTM-EG-004</td><td>Envoy Gateway</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that threat actors establish persistence and move laterally through the cluster unnoticed due to limited visibility into access and application-level activity.</p><p><strong>Threat</strong>: Threat actors establish persistence and move laterally through the cluster unnoticed.</p><p><strong>Recommendation</strong>: Configure <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/proxy-accesslog/>access logging</a> in the EnvoyProxy. Use <a href=/eg-pr-preview/5-test-docs-preview/v1.0/api/extension_types/#proxyaccesslogformattype>ProxyAccessLogFormatType</a> (Text or JSON) to specify the log format and ensure that the logs are sent to the desired sink types by setting the <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#proxyaccesslogsinktype>ProxyAccessLogSinkType</a>. Make use of <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#fileenvoyproxyaccesslog>FileEnvoyProxyAccessLog</a> or <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#opentelemetryenvoyproxyaccesslog>OpenTelemetryEnvoyProxyAccessLog</a> to configure File and OpenTelemetry sinks, respectively. If the settings aren't defined, the default format is sent to stdout.</p><p>Additionally, consider leveraging a central logging mechanism such as <a href=https://github.com/fluent/fluentd>Fluentd</a> to enhance visibility into access activity and enable effective incident response (IR).</p><h3 id=egtm-017-misconfiguration-leads-to-lack-of-envoy-gateway-activity-visibility>EGTM-017 Misconfiguration leads to lack of Envoy Gateway activity visibility<a class=td-heading-self-link href=#egtm-017-misconfiguration-leads-to-lack-of-envoy-gateway-activity-visibility aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-017</td><td>EGTM-EG-005</td><td>Envoy Gateway</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that an insider misconfigures an envoy gateway component and goes unnoticed due to a low-touch logging configuration (via default) which responsible stakeholders are not aptly aware of or have immediate access to.</p><p><strong>Threat</strong>: The threat emerges from an insider misconfiguring an Envoy Gateway component without detection.</p><p><strong>Recommendation</strong>: Configure the logging level of the Envoy Gateway using the 'level' field in <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#envoygatewaylogging>EnvoyGatewayLogging</a>. Ensure the appropriate logging levels are set for relevant components such as 'gateway-api', 'xds-translator', or 'global-ratelimit'. If left unspecified, the logging level defaults to "info", which may not provide sufficient detail for security monitoring.</p><p>Employ a centralised logging mechanism, like <a href=https://github.com/fluent/fluentd>Fluentd</a>, to enhance visibility into application-level activity and to enable efficient incident response.</p><h3 id=egtm-021-exposed-envoy-proxy-admin-interface>EGTM-021 Exposed Envoy Proxy admin interface<a class=td-heading-self-link href=#egtm-021-exposed-envoy-proxy-admin-interface aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-021</td><td>EGTM-EG-006</td><td>Envoy Gateway</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: There is a risk that the admin interface is exposed without valid business reason, increasing the attack surface.</p><p><strong>Threat</strong>: Exposed admin interfaces give internal attackers the option to affect production traffic in unauthorised ways, and the option to exploit any vulnerabilities which may be present in the admin interface (e.g. by orchestrating malicious GET requests to the admin interface through CSRF, compromising Envoy Proxy global configuration or shutting off the service entirely e.g. /quitquitquit).</p><p><strong>Recommendation</strong>: The Envoy Proxy admin interface is only exposed to localhost, meaning that it is secure by default. However, due to the risk of misconfiguration, this recommendation is included.</p><p>Due to the importance of the admin interface, it is recommended to ensure that Envoy Proxies have not been accidentally misconfigured to expose the admin interface to untrusted networks.</p><h3 id=egtm-025-envoy-proxy-pods-deployed-running-as-root-user-in-the-container>EGTM-025 Envoy Proxy pods deployed running as root user in the container<a class=td-heading-self-link href=#egtm-025-envoy-proxy-pods-deployed-running-as-root-user-in-the-container aria-label="Heading self-link"></a></h3><table><thead><tr><th><strong>ID</strong></th><th><strong>UID</strong></th><th><strong>Category</strong></th><th><strong>Priority</strong></th></tr></thead><tbody><tr><td>EGTM-025</td><td>EGTM-CS-011</td><td>Container Security</td><td>Low</td></tr></tbody></table><p><strong>Risk</strong>: The presence of a vulnerability, be it in the kernel or another system component, when coupled with containers running as root, could enable a threat actor to escape the container, thereby compromising the confidentiality, integrity, or availability of cluster resources</p><p><strong>Threat</strong>: The Envoy Proxy container&rsquo;s root-user configuration can be leveraged by an attacker to escalate privileges, execute a container breakout, and traverse across trust boundaries.</p><p><strong>Recommendation</strong>: By default, Envoy Gateway deployments do not use root users. Nonetheless, in case a custom image or deployment manifest is to be used, make sure Envoy Proxy pods run as a non-root user with a high UID within the container.</p><p>Set runAsUser and runAsGroup security context options to specific UIDs (e.g., runAsUser: 1000 & runAsGroup: 3000) to ensure the container operates with the stipulated non-root user and group ID. If using helm chart deployment, define the user and group ID in the values.yaml file or via the command line during helm install / upgrade.</p><h2 id=appendix>Appendix<a class=td-heading-self-link href=#appendix aria-label="Heading self-link"></a></h2><h3 id=in-scope-threat-actor-details>In Scope Threat Actor Details<a class=td-heading-self-link href=#in-scope-threat-actor-details aria-label="Heading self-link"></a></h3><table><thead><tr><th>Threat Actor</th><th>Capability</th><th>Personal Motivation</th><th>Envoy Gateway Attack Samples</th></tr></thead><tbody><tr><td>Application Developer</td><td>Leverage internal knowledge and personal access to the Envoy Gateway infrastructure to move laterally and transit trust boundaries</td><td>Disgruntled / personal grievances.<br><br>Financial incentives</td><td>Misconfigure XRoute resources to expose internal applications.<br><br>Misconfigure SecurityPolicy objects, reducing the security posture of an application.</td></tr><tr><td>Application Administrator</td><td>Abuse privileged status to disrupt operations and tenant cluster services through Envoy Gateway misconfig</td><td>Disgruntled / personal grievances.<br><br>Financial incentives</td><td>Create malicious routes to internal applications.<br><br>Introduce malicious Envoy Proxy images.<br><br>Expose the Envoy Proxy Admin interface.</td></tr><tr><td>Cluster Operator</td><td>Alter application-level deployments by misconfiguring resource dependencies & SCM to introduce vulnerabilities</td><td>Disgruntled / personal grievances.<br><br>Financial incentives.<br><br>Notoriety</td><td>Deploy malicious resources to expose internal applications.<br><br>Access authentication secrets.<br><br>Fall victim to phishing attacks and inadvertently share authentication credentials to cloud infrastructure or Kubernetes clusters.</td></tr><tr><td>Vandal: Script Kiddie, Trespasser</td><td>Uses publicly available tools and applications (Nmap,Metasploit, CVE PoCs)</td><td>Curiosity.<br><br>Personal fame through defacement / denial of service of prominent public facing web resources</td><td>Small scale DOS.<br><br>Launches prepackaged exploits, runs crypto mining tools.<br><br>Exploit public-facing application services such as the bastion host to gain an initial foothold in the environment</td></tr><tr><td>Motivated individual: Political activist, Thief, Terrorist</td><td>Write tools and exploits required for their means if sufficiently motivated.<br><br>Tend to use these in a targeted fashion against specific organisations. May combine publicly available exploits in a targeted fashion. Tamper with open source supply chains</td><td>Personal Gain (Political or Ideological)</td><td>Phishing, DDOS, exploit known vulnerabilities.<br><br>Compromise third-party components such as Helm charts and container images to inject malicious codes to propagate access throughout the environment.</td></tr><tr><td>Organised crime: syndicates, state-affiliated groups</td><td>Write tools and exploits required for their means.<br><br>Tend to use these in a non-targeted fashion, unless motivation is sufficiently high.<br><br>Devotes considerable resources, writes exploits, can bribe/coerce, can launch targeted attacks</td><td>Ransom.<br><br>Mass extraction of PII / credentials / PCI data.<br><br>Financial incentives</td><td>Social Engineering, phishing, ransomware, coordinated attacks.<br><br>Intercept and replay JWT tokens (via MiTM) between tenant user(s) and envoy gateway to modify app configs in-transit</td></tr></tbody></table><h3 id=identified-threats-by-priority>Identified Threats by Priority<a class=td-heading-self-link href=#identified-threats-by-priority aria-label="Heading self-link"></a></h3><table><thead><tr><th>ID</th><th>UID</th><th>Category</th><th>Risk</th><th>Threat</th><th>Priority</th><th>Recommendation</th></tr></thead><tbody><tr><td>EGTM-001</td><td>EGTM-GW-001</td><td>Gateway API</td><td>Self-signed certificates (which do not comply with PKI best practices) could lead to unauthorised access to the private key associated with the certificate used for inbound TLS termination at Envoy Proxy, compromising the confidentiality and integrity of proxied traffic.<br><br></td><td>Compromise of the private key associated with the certificate used for inbound TLS terminating at Envoy Proxy.<br><br></td><td>High</td><td>The Envoy Gateway quickstart guide demonstrates how to set up a Secure Gateway using an example where a self-signed root certificate is created using openssl. As stated in the Envoy Gateway documentation, this is not a suitable configuration for Production usage. It is recommended that PKI best practices are followed, whereby certificates are signed by an Intermediary CA which sits underneath an organisational 'offline' Root CA.<br><br>PKI best practices should also apply to the management of client certificates when using mTLS. The Envoy Gateway <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/mutual-tls/>mTLS</a> guide shows how to set up client certificates using self-signed certificates. In the same way as gateway certificates and, as mentioned in the documentation, this configuration should not be used in production environments.</td></tr><tr><td>EGTM-002</td><td>EGTM-CS-001</td><td>Container Security</td><td>There is a risk that a threat actor could compromise the Kubernetes secret containing the Envoy private key, allowing the attacker to decrypt Envoy Proxy traffic, compromising the confidentiality of proxied traffic.<br><br></td><td>Kubernetes secret containing the Envoy private key is compromised and used to decrypt proxied traffic.<br><br></td><td>High</td><td>Certificate management best practices mandate short-lived key material where practical, meaning that a mechanism for rotation of private keys and certificates is required, along with a way for certificates to be mounted into Envoy containers. If Kubernetes secrets are used, when a certificate expires, the associated secret must be updated, and Envoy containers must be redeployed. Instead of a manual configuration, it is recommended that <a href=https://github.com/cert-manager/cert-manager>cert-manager</a> is used.</td></tr><tr><td>EGTM-004</td><td>EGTM-K8-002</td><td>Container Security</td><td>There is a risk that a threat actor could abuse misconfigured RBAC to access the Envoy Gateway ClusterRole (envoy-gateway-role) and use it to expose all secrets across the cluster, thus compromising the confidentiality and integrity of tenant data.<br><br></td><td>Compromised Envoy Gateway or misconfigured ClusterRoleBinding (envoy-gateway-rolebinding) to Envoy Gateway ClusterRole (envoy-gateway-role), provides access to resources and secrets in different namespaces.<br><br></td><td>High</td><td>Users should be aware that Envoy Gateway uses a ClusterRole (envoy-gateway-role) when deployed via the Helm chart, to allow management of Envoy Proxies across different namespaces. This ClusterRole is powerful and includes the ability to read secrets in namespaces which may not be within the purview of Envoy Gateway.<br><br>Kubernetes best-practices involve restriction of ClusterRoleBindings, with the use of RoleBindings where possible to limit access per namespace by specifying the namespace in metadata. Namespace isolation reduces the impact of compromise from cluster-scoped roles. Ideally, fine-grained K8s roles should be created per the principle of least privilege to ensure they have the minimum access necessary for role functions.<br><br>The pull request #<a href=https://github.com/envoyproxy/gateway/pull/1656>1656</a> introduced the use of Roles and RoleBindings in <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#kuberneteswatchmode>namespaced mode</a>. This feature can be leveraged to reduce the amount of permissions required by the Envoy Gateway.</td></tr><tr><td>EGTM-007</td><td>EGTM-EG-002</td><td>Envoy Gateway</td><td>There is a risk that a threat actor could exploit misconfigured Kubernetes RBAC to create or modify Gateway API resources with no business need, potentially leading to the compromise of the confidentiality, integrity, and availability of resources and traffic within the cluster.<br><br></td><td>Unauthorised creation or misconfiguration of Gateway API resources by a threat actor with cluster-scoped access.<br><br></td><td>High</td><td>Configure the apiGroup and resource fields in RBAC policies to restrict access to <a href=https://gateway-api.sigs.k8s.io/>Gateway</a> and <a href=https://gateway-api.sigs.k8s.io/api-types/gatewayclass/>GatewayClass</a> resources. Enable namespace isolation by using the namespace field, preventing unauthorised access to gateways in other namespaces.</td></tr><tr><td>EGTM-009</td><td>EGTM-GW-002</td><td>Gateway API</td><td>There is a risk that a co-tenant misconfigures Gateway or Route resources, compromising the confidentiality, integrity, and availability of routed traffic through Envoy Gateway.<br><br></td><td>Malicious or accidental co-tenant misconfiguration of Gateways and Routes associated with other application teams.<br><br></td><td>High</td><td>Dedicated Envoy Gateways should be provided to each tenant within their respective namespace. A one-to-one relationship should be established between GatewayClass and Gateway resources, meaning that each tenant namespace should have their own GatewayClass watched by a unique Envoy Gateway Controller as defined here in the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/deployment-mode/>Deployment Mode</a> documentation.<br><br>Application Admins should have write permissions on the Gateway resource, but only in their specific namespaces, and Application Developers should only hold write permissions on Route resources. To enact this access control schema, follow the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#write-permissions-for-advanced-4-tier-model>Write Permissions for Advanced 4 Tier Model</a> described in the Kubernetes Gateway API security model. Examples of secured gateway-route topologies can be found <a href=https://gateway-api.sigs.k8s.io/concepts/api-overview/#attaching-routes-to-gateways>here</a> within the Kubernetes Gateway API docs.<br><br>Optionally, consider a GitOps model, where only the GitOps operator has the permission to deploy or modify custom resources in production.</td></tr><tr><td>EGTM-014</td><td>EGTM-CS-006</td><td>Container Security</td><td>There is a risk that a supply chain attack on Envoy Gateway results in an arbitrary compromise of the confidentiality, integrity or availability of tenant data.<br><br></td><td>Supply chain threat actor introduces malicious code into Envoy Gateway or Proxy.<br><br></td><td>High</td><td>The Envoy Gateway project should continue to work towards conformance with supply-chain security best practices throughout the project lifecycle (for example, as set out in the <a href=https://github.com/cncf/tag-security/blob/main/supply-chain-security/supply-chain-security-paper/CNCF_SSCP_v1.pdf>CNCF Software Supply Chain Best Practices Whitepaper</a>. Adherence to <a href=https://slsa.dev/>Supply-chain Levels for Software Artefacts</a> (SLSA) standards is crucial for maintaining the security of the system. Employ version control systems to monitor the source and build platforms and assign responsibility to a specific stakeholder.<br><br>Integrate a supply chain security tool such as Sigstore, which provides native capabilities for signing and verifying container images and software artefacts. <a href=https://www.cisa.gov/sbom>Software Bill of Materials</a> (SBOM), <a href=https://www.ntia.gov/files/ntia/publications/vex_one-page_summary.pdf>Vulnerability Exploitability eXchange</a> (VEX), and signed artefacts should also be incorporated into the security protocol.</td></tr><tr><td>EGTM-020</td><td>EGTM-CS-009</td><td>Container Security</td><td>There is a risk that a threat actor exploits an Envoy Proxy vulnerability to remote code execution (RCE) due to out of date or misconfigured Envoy Proxy pod deployment, compromising the confidentiality and integrity of Envoy Proxy along with the availability of the proxy service.<br><br></td><td>Deployment of an Envoy Proxy or Gateway image containing exploitable CVEs.<br><br></td><td>High</td><td>Always use the latest version of the Envoy Proxy image. Regularly check for updates and patch the system as soon as updates become available. Implement a CI/CD pipeline that includes security checks for images and prevents deployment of insecure configurations. A tool such as Snyk can be used to provide container vulnerability scanning to mitigate the risk of known vulnerabilities.<br><br>Utilise the <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/>Pod Security Admission</a> controller to enforce <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a> and configure the <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>pod security context</a> to limit its capabilities per the principle of least privilege.</td></tr><tr><td>EGTM-022</td><td>EGTM-CS-010</td><td>Container Security</td><td>There is a risk that the OIDC client secret (for OIDC authentication) and user password hashes (for basic authentication) get leaked due to misconfigured RBAC permissions.<br><br></td><td>Unauthorised access to the application due to credential leakage.<br><br></td><td>High</td><td>Ensure that only authorised users and service accounts are able to access secrets. This is especially important in namespaces where SecurityPolicy objects are configured, since those namespaces are the ones to store secrets containing the client secret (in OIDC scenarios) and user password hashes (in basic authentication scenarios).<br><br>To do so, minimise the use of ClusterRoles and Roles allowing listing and getting secrets. Perform periodic audits of RBAC permissions.</td></tr><tr><td>EGTM-023</td><td>EGTM-EG-007</td><td>Envoy Gateway</td><td>There is a risk of unauthorised access due to the use of basic authentication, which does not enforce any password restriction in terms of complexity and length. In addition, password hashes are stored in SHA1 format, which is a deprecated hashing function.<br><br></td><td>Unauthorised access to the application due to weak authentication mechanisms.<br><br></td><td>High</td><td>It is recommended to make use of stronger authentication mechanisms (i.e. JWT authentication and OIDC authentication) instead of basic authentication. These authentication mechanisms have many advantages, such as the use of short-lived credentials and a central management of security policies through the identity provider.</td></tr><tr><td>EGTM-008</td><td>EGTM-EG-003</td><td>Envoy Gateway</td><td>There is a risk of a threat actor misconfiguring static config and compromising the integrity of Envoy Gateway, ultimately leading to the compromised confidentiality, integrity, or availability of tenant data and cluster resources.<br><br></td><td>Accidental or deliberate misconfiguration of static configuration leads to a misconfigured deployment of Envoy Gateway, for example logging parameters could be modified or global rate limiting configuration misconfigured.<br><br></td><td>Medium</td><td>Implement a GitOps model, utilising Kubernetes' Role-Based Access Control (RBAC) and adhering to the principle of least privilege to minimise human intervention on the cluster. For instance, tools like <a href=https://argo-cd.readthedocs.io/en/stable/>ArgoCD</a> can be used for declarative GitOps deployments, ensuring all changes are tracked and reviewed. Additionally, configure your source control management (SCM) system to include mandatory pull request (PR) reviews, commit signing, and protected branches to ensure only authorised changes can be committed to the start-up configuration.</td></tr><tr><td>EGTM-010</td><td>EGTM-CS-005</td><td>Container Security</td><td>There is a risk that a threat actor exploits a weak pod security context, compromising the CIA of a node and the resources / services which run on it.<br><br></td><td>Threat Actor who has compromised a pod exploits weak security context to escape to a node, potentially leading to the compromise of Envoy Proxy or Gateway running on the same node.<br><br></td><td>Medium</td><td>To mitigate this risk, apply <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/>Pod Security Standards</a> at a minimum of <a href=https://kubernetes.io/docs/concepts/security/pod-security-standards/#baseline>Baseline</a> level to all namespaces, especially those containing Envoy Gateway and Proxy Pods. Pod security standards are implemented through K8s <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/>Pod Security Admission</a> to provide <a href=https://kubernetes.io/docs/concepts/security/pod-security-admission/#pod-security-admission-labels-for-namespaces>admission control modes</a> (enforce, audit, and warn) for namespaces. Pod security standards can be enforced by namespace labels as shown <a href=https://kubernetes.io/docs/tasks/configure-pod-container/enforce-standards-namespace-labels/>here</a>, to enforce a baseline level of pod security to specific namespaces.<br><br>Further enhance the security by implementing a sandboxing solution such as <a href=https://gvisor.dev/>gVisor</a> for Envoy Gateway and Proxy Pods to isolate the application from the host kernel. This can be set within the runtimeClassName of the Pod specification.</td></tr><tr><td>EGTM-012</td><td>EGTM-GW-004</td><td>Gateway API</td><td>There is a risk that a threat actor could abuse excessive RBAC privileges to create ReferenceGrant resources. These resources could then be used to create cross-namespace communication, leading to unauthorised access to the application. This could compromise the confidentiality and integrity of resources and configuration in the affected namespaces and potentially disrupt the availability of services that rely on these object references.<br><br></td><td>A ReferenceGrant is created, which validates traffic to cross namespace trust boundaries without a valid business reason, such as a route in one tenant's namespace referencing a backend in another.<br><br></td><td>Medium</td><td>Ensure that the ability to create ReferenceGrant resources is restricted to the minimum number of people. Pay special attention to ClusterRoles that allow that action.</td></tr><tr><td>EGTM-018</td><td>EGTM-GW-006</td><td>Gateway API</td><td>There is a risk that malicious requests could lead to a Denial of Service (DoS) attack, thereby reducing API gateway availability due to misconfigurations in rate-limiting or load balancing controls, or a lack of route timeout enforcement.<br><br></td><td>Reduced API gateway availability due to an attacker's maliciously crafted request (e.g., QoD) potentially inducing a Denial of Service (DoS) attack.<br><br></td><td>Medium</td><td>To ensure high availability and to mitigate potential security threats, adhere to the Envoy Gateway documentation for the configuration of a <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/traffic/global-rate-limit/>rate-limiting</a> filter and load balancing.<br><br>Further, adhere to best practices for configuring Envoy Proxy as an edge proxy documented <a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/best_practices/edge#configuring-envoy-as-an-edge-proxy>here</a> within the EnvoyProxy docs. This involves configuring TCP and HTTP proxies with specific settings, including restricting access to the admin endpoint, setting the <a href=https://www.envoyproxy.io/docs/envoy/latest/configuration/operations/overload_manager/overload_manager#config-overload-manager>overload manager</a> and <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#envoy-v3-api-field-config-listener-v3-listener-per-connection-buffer-limit-bytes>listener</a> / <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#envoy-v3-api-field-config-cluster-v3-cluster-per-connection-buffer-limit-bytes>cluster</a> buffer limits, enabling <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-use-remote-address>use_remote_address</a>, setting <a href=https://www.envoyproxy.io/docs/envoy/latest/faq/configuration/timeouts#faq-configuration-timeouts>connection and stream timeouts</a>, limiting <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-http2protocoloptions-max-concurrent-streams>maximum concurrent streams</a>, setting <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-http2protocoloptions-initial-stream-window-size>initial stream window size limit</a>, and configuring action on <a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/protocol.proto#envoy-v3-api-field-config-core-v3-httpprotocoloptions-headers-with-underscores-action>headers_with_underscores</a>.<br><br><a href=https://www.envoyproxy.io/docs/envoy/latest/api-v3/extensions/filters/network/http_connection_manager/v3/http_connection_manager.proto#envoy-v3-api-field-extensions-filters-network-http-connection-manager-v3-httpconnectionmanager-normalize-path>Path normalisation</a> should be enabled to minimise path confusion vulnerabilities. These measures help protect against volumetric threats such as Denial of Service (DoS)nattacks. Utilise custom resources to implement policy attachment, thereby exposing request limit configuration for route types.</td></tr><tr><td>EGTM-019</td><td>EGTM-DP-004</td><td>Container Security</td><td>There is a risk that replay attacks using stolen or reused JSON Web Tokens (JWTs) can compromise transmission integrity, thereby undermining the confidentiality and integrity of the data plane.<br><br></td><td>Transmission integrity is compromised due to replay attacks using stolen or reused JSON Web Tokens (JWTs).<br><br></td><td>Medium</td><td>Comply with JWT best practices for enhanced security, paying special attention to the use of short-lived tokens, which reduce the window of opportunity for a replay attack. The <a href=https://datatracker.ietf.org/doc/html/rfc7519#page-9>exp</a> claim can be used to set token expiration times.</td></tr><tr><td>EGTM-024</td><td>EGTM-EG-008</td><td>Envoy Gateway</td><td>There is a risk of developers getting more privileges than required due to the use of SecurityPolicy, ClientTrafficPolicy, EnvoyPatchPolicy and BackendTrafficPolicy. These resources can be attached to a Gateway resource. Therefore, a developer with permission to deploy them would be able to modify a Gateway configuration by targeting the gateway in the policy manifest. This conflicts with the <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#write-permissions-for-advanced-4-tier-model>Advanced 4 Tier Model</a>, where developers do not have write permissions on Gateways.<br><br></td><td>Excessive developer permissions lead to a misconfiguration and/or unauthorised access.<br><br></td><td>Medium</td><td>Considering the Tenant C scenario (represented in the Architecture Diagram), if a developer can create SecurityPolicy, ClientTrafficPolicy, EnvoyPatchPolicy or BackendTrafficPolicy objects in namespace C, they would be able to modify a Gateway configuration by attaching the policy to the gateway. In such scenarios, it is recommended to either:<br><br>a. Create a separate namespace, where developers have no permissions, > to host tenant C's gateway. Note that, due to design decisions, > the > SecurityPolicy/EnvoyPatchPolicy/ClientTrafficPolicy/BackendTrafficPolicy > object can only target resources deployed in the same namespace. > Therefore, having a separate namespace for the gateway would > prevent developers from attaching the policy to the gateway.<br><br>b. Forbid the creation of these policies for developers in namespace C.<br><br>On the other hand, in scenarios similar to tenants A and B, where a shared gateway namespace is in place, this issue is more limited. Note that in this scenario, developers don't have access to the shared gateway namespace.<br><br>In addition, it is important to mention that EnvoyPatchPolicy resources can also be attached to GatewayClass resources. This means that, in order to comply with the Advanced 4 Tier model, individuals with the Application Administrator role should not have access to this resource either.</td></tr><tr><td>EGTM-003</td><td>EGTM-EG-001</td><td>Envoy Gateway</td><td>There is a risk that a threat actor could downgrade the security of proxied connections by configuring a weak set of cipher suites, compromising the confidentiality and integrity of proxied traffic.<br><br></td><td>Exploit weak cipher suite configuration to downgrade security of proxied connections.<br><br></td><td>Low</td><td>Users operating in highly regulated environments may need to tightly control the TLS protocol and associated cipher suites, blocking non-conforming incoming connections to the gateway.<br><br>EnvoyProxy bootstrap config can be customised as per the <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/operations/customize-envoyproxy/>customise EnvoyProxy</a> documentation. In addition, from v.1.0.0, it is possible to configure common TLS properties for a Gateway or XRoute through the <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#clienttrafficpolicy>ClientTrafficPolicy</a> object.</td></tr><tr><td>EGTM-005</td><td>EGTM-CP-002</td><td>Container Security</td><td>Threat actor who has obtained access to Envoy Gateway pod could exploit the lack of AppArmor and Seccomp profiles in the Envoy Gateway deployment to attempt a container breakout, given the presence of an exploitable vulnerability, potentially impacting the confidentiality and integrity of namespace resources.<br><br></td><td>Unauthorised syscalls and malicious code running in the Envoy Gateway pod.<br><br></td><td>Low</td><td>Implement <a href=https://kubernetes.io/docs/tutorials/security/apparmor/>AppArmor</a> policies by setting &lt;container_name>: &lt;profile_ref> within container.apparmor.security.beta.kubernetes.io (note, this config is set <em>per container</em>). Well-defined AppArmor policies may provide greater protection from unknown threats.<br><br>Enforce <a href=https://kubernetes.io/docs/tutorials/security/seccomp/>Seccomp</a> profiles by setting the seccompProfile under securityContext. Ideally, a <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#create-pod-with-a-seccomp-profile-that-only-allows-necessary-syscalls>fine-grained</a> profile should be used to restrict access to only necessary syscalls, however the --seccomp-default flag can be set to resort to <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#create-pod-that-uses-the-container-runtime-default-seccomp-profile>RuntimeDefault</a> which provides a container runtime specific. Example seccomp profiles can be found <a href=https://kubernetes.io/docs/tutorials/security/seccomp/#download-profiles>here</a>.<br><br>To further enhance pod security, consider implementing <a href=https://en.wikipedia.org/wiki/Security-Enhanced_Linux>SELinux</a> via seLinuxOptions for additional syscall attack surface reduction. Setting readOnlyRootFilesystem == true enforces an immutable root filesystem, preventing the addition of malicious binaries to the PATH and increasing the attack cost. Together, these configuration items improve the pods <a href=https://kubernetes.io/docs/tasks/configure-pod-container/security-context/>Security Context</a>.</td></tr><tr><td>EGTM-006</td><td>EGTM-CS-004</td><td>Container Security</td><td>There is a risk that a threat actor exploits a vulnerability in Envoy Proxy to expose a reverse shell, enabling them to compromise the confidentiality, integrity and availability of tenant data via a secondary attack.<br><br></td><td>If an external attacker managed to exploit a vulnerability in Envoy, the presence of a shell would be greatly helpful for the attacker in terms of potentially pivoting, escalating, or establishing some form of persistence.<br><br></td><td>Low</td><td>By default, Envoy uses a <a href=https://github.com/GoogleContainerTools/distroless>distroless</a> image since v.0.6.0, which does not ship a shell. Therefore, ensure EnvoyProxy image is up-to-date and patched with the latest stable version.<br><br>If using private EnvoyProxy images, use a lightweight EnvoyProxy image without a shell or debugging tool(s) which may be useful for an attacker.<br><br>An <a href=https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/#audit-policy>AuditPolicy</a> (audit.k8s.io/v1beta1) can be configured to record API calls made within your cluster, allowing for identification of malicious traffic and enabling incident response. Requests are recorded based on stages which delineate between the lifecycle stage of the request made (e.g., RequestReceived, ResponseStarted, & ResponseComplete).</td></tr><tr><td>EGTM-011</td><td>EGTM-GW-003</td><td>Gateway API</td><td>There is a risk that a gateway owner (or someone with the ability to set namespace labels) maliciously or accidentally binds routes across namespace boundaries, potentially compromising the confidentiality and integrity of traffic in a multitenant scenario.<br><br></td><td>If a Route Binding within a Gateway Listener is configured based on a custom label, it could allow a malicious internal actor with the ability to label namespaces to change the set of namespaces supported by the Gateway<br><br></td><td>Low</td><td>Consider the use of custom admission control to restrict what labels can be set on namespaces through tooling such as <a href=https://kyverno.io/policies/pod-security/>Kubewarden</a>, <a href=https://github.com/kubewarden>Kyverno</a>, and <a href=https://github.com/open-policy-agent/gatekeeper>OPA Gatekeeper</a>. Route binding should follow the Kubernetes Gateway API security model, as shown <a href=https://gateway-api.sigs.k8s.io/concepts/security-model/#1-route-binding>here</a>, to connect gateways in different namespaces.</td></tr><tr><td>EGTM-013</td><td>EGTM-GW-005</td><td>Gateway API</td><td>There is a risk that an unauthorised actor deploys an unauthorised GatewayClass due to GatewayClass namespace validation not being configured, leading to non-compliance with business and security requirements.<br><br></td><td>Unauthorised deployment of Gateway resource via GatewayClass template which crosses namespace trust boundaries.<br><br></td><td>Low</td><td>Leverage GatewayClass namespace validation to limit the namespaces where GatewayClasses can be run through a tool such as using <a href=https://github.com/open-policy-agent/gatekeeper>OPA Gatekeeper</a>. Reference pull request #<a href=https://github.com/open-policy-agent/gatekeeper-library/pull/24>24</a> within gatekeeper-library which outlines how to add GatewayClass namespace validation through a GatewayClassNamespaces API resource kind within the constraints.gatekeeper.sh/v1beta1 apiGroup.</td></tr><tr><td>EGTM-015</td><td>EGTM-CS-007</td><td>Container Security</td><td>There is a risk that threat actors could exploit ServiceAccount tokens for illegitimate authentication, thereby leading to privilege escalation and the undermining of gateway API resources' integrity, confidentiality, and availability.<br><br></td><td>The threat arises from threat actors impersonating the envoy-gateway ServiceAccount through the replay of ServiceAccount tokens, thereby achieving escalated privileges and gaining unauthorised access to Kubernetes resources.<br><br></td><td>Low</td><td>Limit the creation of ServiceAccounts to only when necessary, specifically refraining from using default service account tokens, especially for high-privilege service accounts. For legacy clusters running Kubernetes version 1.21 or earlier, note that ServiceAccount tokens are long-lived by default. To disable the automatic mounting of the service account token, set automountServiceAccountToken: false in the PodSpec.</td></tr><tr><td>EGTM-016</td><td>EGTM-EG-004</td><td>Envoy Gateway</td><td>There is a risk that threat actors establish persistence and move laterally through the cluster unnoticed due to limited visibility into access and application-level activity.<br><br></td><td>Threat actors establish persistence and move laterally through the cluster unnoticed.<br><br></td><td>Low</td><td>Configure <a href=/eg-pr-preview/5-test-docs-preview/contributions/design/proxy-accesslog/>access logging</a> in the EnvoyProxy. Use <a href=/eg-pr-preview/5-test-docs-preview/v1.0/api/extension_types/#proxyaccesslogformattype>ProxyAccessLogFormatType</a> (Text or JSON) to specify the log format and ensure that the logs are sent to the desired sink types by setting the <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#proxyaccesslogsinktype>ProxyAccessLogSinkType</a>. Make use of <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#fileenvoyproxyaccesslog>FileEnvoyProxyAccessLog</a> or <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#opentelemetryenvoyproxyaccesslog>OpenTelemetryEnvoyProxyAccessLog</a> to configure File and OpenTelemetry sinks, respectively. If the settings aren't defined, the default format is sent to stdout.<br><br>Additionally, consider leveraging a central logging mechanism such as <a href=https://github.com/fluent/fluentd>Fluentd</a> to enhance visibility into access activity and enable effective incident response (IR).</td></tr><tr><td>EGTM-017</td><td>EGTM-EG-005</td><td>Envoy Gateway</td><td>There is a risk that an insider misconfigures an envoy gateway component and goes unnoticed due to a low-touch logging configuration (via default) which responsible stakeholders are not aptly aware of or have immediate access to.<br><br></td><td>The threat emerges from an insider misconfiguring an Envoy Gateway component without detection.<br><br></td><td>Low</td><td>Configure the logging level of the Envoy Gateway using the 'level' field in <a href=https://gateway.envoyproxy.io/latest/api/extension_types/#envoygatewaylogging>EnvoyGatewayLogging</a>. Ensure the appropriate logging levels are set for relevant components such as 'gateway-api', 'xds-translator', or 'global-ratelimit'. If left unspecified, the logging level defaults to "info", which may not provide sufficient detail for security monitoring.<br><br>Employ a centralised logging mechanism, like <a href=https://github.com/fluent/fluentd>Fluentd</a>, to enhance visibility into application-level activity and to enable efficient incident response.</td></tr><tr><td>EGTM-021</td><td>EGTM-EG-006</td><td>Envoy Gateway</td><td>There is a risk that the admin interface is exposed without valid business reason, increasing the attack surface.<br><br></td><td>Exposed admin interfaces give internal attackers the option to affect production traffic in unauthorised ways, and the option to exploit any vulnerabilities which may be present in the admin interface (e.g. by orchestrating malicious GET requests to the admin interface through CSRF, compromising Envoy Proxy global configuration or shutting off the service entirely (e.g., /quitquitquit).<br><br></td><td>Low</td><td>The Envoy Proxy admin interface is only exposed to localhost, meaning that it is secure by default. However, due to the risk of misconfiguration, this recommendation is included.<br><br>Due to the importance of the admin interface, it is recommended to ensure that Envoy Proxies have not been accidentally misconfigured to expose the admin interface to untrusted networks.</td></tr><tr><td>EGTM-025</td><td>EGTM-CS-011</td><td>Container Security</td><td>The presence of a vulnerability, be it in the kernel or another system component, when coupled with containers running as root, could enable a threat actor to escape the container, thereby compromising the confidentiality, integrity, or availability of cluster resources.</td><td>The Envoy Proxy container&rsquo;s root-user configuration can be leveraged by an attacker to escalate privileges, execute a container breakout, and traverse across trust boundaries.</td><td>Low</td><td>By default, Envoy Gateway deployments do not use root users. Nonetheless, in case a custom image or deployment manifest is to be used, make sure Envoy Proxy pods run as a non-root user with a high UID within the container. Set runAsUser and runAsGroup security context options to specific UIDs (e.g., runAsUser: 1000 & runAsGroup: 3000) to ensure the container operates with the stipulated non-root user and group ID. If using helm chart deployment, define the user and group ID in the values.yaml file or via the command line during helm install / upgrade.</td></tr></tbody></table><h2 id=attack-trees>Attack Trees<a class=td-heading-self-link href=#attack-trees aria-label="Heading self-link"></a></h2><p>Attack trees offer a methodical way of describing the security of systems, based on varying attack patterns. It&rsquo;s important to approach the review of attack trees from a top-down perspective. The top node, also known as the root node, symbolises the attacker&rsquo;s primary objective. This goal is then broken down into subsidiary aims, each reflecting a different strategy to attain the root objective. This deconstruction persists until reaching the lowest level objectives or &rsquo;leaf nodes&rsquo;, which depict attacks that can be directly launched.</p><p>It is essential to note that attack trees presented here are speculative paths for potential exploitation. The Envoy Gateway project is in a continuous development cycle, and as the project evolves, new vulnerabilities may be exposed, or additional controls could be introduced. Therefore, the threats illustrated in the attack trees should be perceived as point-in-time reflections of the project’s current state at the time of writing this threat model.</p><h3 id=node-id-schema>Node ID Schema<a class=td-heading-self-link href=#node-id-schema aria-label="Heading self-link"></a></h3><p>Each node in the attack tree is assigned a unique identifier following the AT#-## schema. This allows easy reference to specific nodes in the attack trees throughout the threat model. The first part of the ID (AT#) signifies the attack tree number, while the second part (##) represents the node number within that tree.</p><h3 id=logical-operators>Logical Operators<a class=td-heading-self-link href=#logical-operators aria-label="Heading self-link"></a></h3><p>Logical AND/OR operators are used to represent the relationship between parent and child nodes. An AND operator means that all child nodes must be achieved to satisfy the parent node. An OR operator between a parent node and its child nodes means that any of the child nodes can be achieved to satisfy the parent node.</p><h3 id=attack-tree-node-legend>Attack Tree Node Legend<a class=td-heading-self-link href=#attack-tree-node-legend aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT-legend.png alt="AT Legend"></p><h3 id=at0>AT0<a class=td-heading-self-link href=#at0 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT0.png alt=AT0></p><h3 id=at1>AT1<a class=td-heading-self-link href=#at1 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT1.png alt=AT1></p><h3 id=at2>AT2<a class=td-heading-self-link href=#at2 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT2.png alt=AT2></p><h3 id=at3>AT3<a class=td-heading-self-link href=#at3 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT3.png alt=AT3></p><h3 id=at4>AT4<a class=td-heading-self-link href=#at4 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT4.png alt=AT4></p><h3 id=at5>AT5<a class=td-heading-self-link href=#at5 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT5.png alt=AT5></p><h3 id=at6>AT6<a class=td-heading-self-link href=#at6 aria-label="Heading self-link"></a></h3><p><img src=https://zirain.github.io/eg-pr-preview/5-test-docs-preview//img/AT6.png alt=AT6></p></div><div class=td-content style=page-break-before:always><h1 id=pg-4ba8db1bf690717020b2801692fdfb57>10 - TLS Passthrough</h1><p>This task will walk through the steps required to configure TLS Passthrough via Envoy Gateway. Unlike configuring
Secure Gateways, where the Gateway terminates the client TLS connection, TLS Passthrough allows the application itself
to terminate the TLS connection, while the Gateway routes the requests to the application based on SNI headers.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>OpenSSL to generate TLS assets.</li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=tls-certificates>TLS Certificates<a class=td-heading-self-link href=#tls-certificates aria-label="Heading self-link"></a></h2><p>Generate the certificates and keys used by the Service to terminate client TLS connections.
For the application, we&rsquo;ll deploy a sample echoserver app, with the certificates loaded in the application Pod.</p><p><strong>Note:</strong> These certificates will not be used by the Gateway, but will remain in the application scope.</p><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout example.com.key -out example.com.crt
</span></span></code></pre></div><p>Create a certificate and a private key for <code>passthrough.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out passthrough.example.com.csr -newkey rsa:2048 -nodes -keyout passthrough.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=passthrough.example.com/O=some organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -sha256 -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in passthrough.example.com.csr -out passthrough.example.com.crt
</span></span></code></pre></div><p>Store the cert/keys in A Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls server-certs --key<span style=color:#ce5c00;font-weight:700>=</span>passthrough.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>passthrough.example.com.crt
</span></span></code></pre></div><h2 id=deployment>Deployment<a class=td-heading-self-link href=#deployment aria-label="Heading self-link"></a></h2><p>Deploy TLS Passthrough application Deployment, Service and TLSRoute:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/tls-passthrough.yaml
</span></span></code></pre></div><p>Patch the Gateway from the Quickstart to include a TLS listener that listens on port <code>6443</code> and is configured for
TLS mode Passthrough:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl patch gateway eg --type<span style=color:#ce5c00;font-weight:700>=</span>json --patch <span style=color:#4e9a06>&#39;
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>  - op: add
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    path: /spec/listeners/-
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>    value:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      name: tls
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      protocol: TLS
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      hostname: passthrough.example.com
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      port: 6443
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>      tls:
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>        mode: Passthrough
</span></span></span><span style=display:flex><span><span style=color:#4e9a06>   &#39;</span>
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 6043:6443 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Curl the example app through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v --resolve <span style=color:#4e9a06>&#34;passthrough.example.com:6043:127.0.0.1&#34;</span> https://passthrough.example.com:6043 <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert passthrough.example.com.crt
</span></span></code></pre></div><h3 id=clusters-with-external-loadbalancer-support>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>You can also test the same functionality by sending traffic to the External IP of the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>GATEWAY_HOST</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get gateway/eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.addresses[0].value}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Curl the example app through the Gateway, e.g. Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:passthrough.example.com --resolve <span style=color:#4e9a06>&#34;passthrough.example.com:6443:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://passthrough.example.com:6443/get
</span></span></code></pre></div><h2 id=clean-up>Clean-Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to uninstall Envoy Gateway and the example manifest.</p><p>Delete the Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl delete secret/server-certs
</span></span></code></pre></div><h2 id=next-steps>Next Steps<a class=td-heading-self-link href=#next-steps aria-label="Heading self-link"></a></h2><p>Checkout the <a href=/eg-pr-preview/5-test-docs-preview/contributions/develop/>Developer Guide</a> to get involved in the project.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-713ead56ff8675156288cb286ef620f4>11 - TLS Termination for TCP</h1><p>This guide will walk through the steps required to configure TLS Terminate mode for TCP traffic via Envoy Gateway. The guide uses a self-signed CA, so it should be used for testing and demonstration purposes only.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>OpenSSL to generate TLS assets.</li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway.</p><h2 id=tls-certificates>TLS Certificates<a class=td-heading-self-link href=#tls-certificates aria-label="Heading self-link"></a></h2><p>Generate the certificates and keys used by the Gateway to terminate client TLS connections.</p><p>Create a root certificate and private key to sign certificates:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -x509 -sha256 -nodes -days <span style=color:#0000cf;font-weight:700>365</span> -newkey rsa:2048 -subj <span style=color:#4e9a06>&#39;/O=example Inc./CN=example.com&#39;</span> -keyout example.com.key -out example.com.crt
</span></span></code></pre></div><p>Create a certificate and a private key for <code>www.example.com</code>:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>openssl req -out www.example.com.csr -newkey rsa:2048 -nodes -keyout www.example.com.key -subj <span style=color:#4e9a06>&#34;/CN=www.example.com/O=example organization&#34;</span>
</span></span><span style=display:flex><span>openssl x509 -req -days <span style=color:#0000cf;font-weight:700>365</span> -CA example.com.crt -CAkey example.com.key -set_serial <span style=color:#0000cf;font-weight:700>0</span> -in www.example.com.csr -out www.example.com.crt
</span></span></code></pre></div><p>Store the cert/key in a Secret:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl create secret tls example-cert --key<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.key --cert<span style=color:#ce5c00;font-weight:700>=</span>www.example.com.crt
</span></span></code></pre></div><p>Install the TLS Termination for TCP example resources:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl apply -f https://raw.githubusercontent.com/envoyproxy/gateway/latest/examples/kubernetes/tls-termination.yaml
</span></span></code></pre></div><p>Verify the Gateway status:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get gateway/eg -o yaml
</span></span></code></pre></div><h2 id=testing>Testing<a class=td-heading-self-link href=#testing aria-label="Heading self-link"></a></h2><h3 id=clusters-without-external-loadbalancer-support>Clusters without External LoadBalancer Support<a class=td-heading-self-link href=#clusters-without-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the name of the Envoy service created the by the example Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>ENVOY_SERVICE</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get svc -n envoy-gateway-system --selector<span style=color:#ce5c00;font-weight:700>=</span>gateway.envoyproxy.io/owning-gateway-namespace<span style=color:#ce5c00;font-weight:700>=</span>default,gateway.envoyproxy.io/owning-gateway-name<span style=color:#ce5c00;font-weight:700>=</span>eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.items[0].metadata.name}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Port forward to the Envoy service:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl -n envoy-gateway-system port-forward service/<span style=color:#4e9a06>${</span><span style=color:#000>ENVOY_SERVICE</span><span style=color:#4e9a06>}</span> 8443:443 <span style=color:#000;font-weight:700>&amp;</span>
</span></span></code></pre></div><p>Query the example app through Envoy proxy:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:8443:127.0.0.1&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com:8443/get
</span></span></code></pre></div><h3 id=clusters-with-external-loadbalancer-support>Clusters with External LoadBalancer Support<a class=td-heading-self-link href=#clusters-with-external-loadbalancer-support aria-label="Heading self-link"></a></h3><p>Get the External IP of the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#204a87>export</span> <span style=color:#000>GATEWAY_HOST</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>kubectl get gateway/eg -o <span style=color:#000>jsonpath</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;{.status.addresses[0].value}&#39;</span><span style=color:#204a87;font-weight:700>)</span>
</span></span></code></pre></div><p>Query the example app through the Gateway:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -v -HHost:www.example.com --resolve <span style=color:#4e9a06>&#34;www.example.com:443:</span><span style=color:#4e9a06>${</span><span style=color:#000>GATEWAY_HOST</span><span style=color:#4e9a06>}</span><span style=color:#4e9a06>&#34;</span> <span style=color:#4e9a06>\
</span></span></span><span style=display:flex><span><span style=color:#4e9a06></span>--cacert example.com.crt https://www.example.com/get
</span></span></code></pre></div></div><div class=td-content style=page-break-before:always><h1 id=pg-59259f34ed2392ad6f2afc9f76e365cf>12 - Using cert-manager For TLS Termination</h1><p>This guide shows how to set up <a href=https://cert-manager.io/>cert-manager</a> to automatically create certificates and secrets for use by Envoy Gateway.
It will first show how to enable the self-sign issuer, which is useful to test that cert-manager and Envoy Gateway can talk to each other.
Then it shows how to use <a href=https://letsencrypt.org/docs/staging-environment/>Let&rsquo;s Encrypt&rsquo;s staging environment</a>.
Changing to the Let&rsquo;s Encrypt production environment is straight-forward after that.</p><h2 id=prerequisites>Prerequisites<a class=td-heading-self-link href=#prerequisites aria-label="Heading self-link"></a></h2><ul><li>A Kubernetes cluster and a configured <code>kubectl</code>.</li><li>The <code>helm</code> command.</li><li>The <code>curl</code> command or similar for testing HTTPS requests.</li><li>For the ACME HTTP-01 challenge to work<ul><li>your Gateway must be reachable on the public Internet.</li><li>the domain name you use (we use <code>www.example.com</code>) must point to the Gateway&rsquo;s external IP(s).</li></ul></li></ul><h2 id=installation>Installation<a class=td-heading-self-link href=#installation aria-label="Heading self-link"></a></h2><p>Follow the steps from the <a href=../../quickstart>Quickstart</a> to install Envoy Gateway and the example manifest.
Before proceeding, you should be able to query the example backend using HTTP.</p><h2 id=deploying-cert-manager>Deploying cert-manager<a class=td-heading-self-link href=#deploying-cert-manager aria-label="Heading self-link"></a></h2><p><em>This is a summary of <a href=https://cert-manager.io/docs/installation/helm/>cert-manager Installation with Helm</a>.</em></p><p>Installing cert-manager is straight-forward, but currently (v1.12) requires setting a feature gate to enable the Gateway API support.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> helm repo add jetstack https://charts.jetstack.io
</span></span><span style=display:flex><span><span style=color:#8f5902>$</span> helm upgrade --install --create-namespace --namespace cert-manager --set <span style=color:#000>installCRDs</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87>true</span> --set <span style=color:#000>featureGates</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>ExperimentalGatewayAPISupport</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87>true</span> cert-manager jetstack/cert-manager
</span></span></code></pre></div><p>You should now have <code>cert-manager</code> running with nothing to do:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl <span style=color:#204a87>wait</span> --for<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>condition</span><span style=color:#ce5c00;font-weight:700>=</span>Available deployment -n cert-manager --all
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>deployment.apps/cert-manager condition met
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>deployment.apps/cert-manager-cainjector condition met
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>deployment.apps/cert-manager-webhook condition met
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic></span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902>$</span> kubectl get -n cert-manager deployment
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME                      READY   UP-TO-DATE   AVAILABLE   AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>cert-manager              1/1     1            1           42m
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>cert-manager-cainjector   1/1     1            1           42m
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>cert-manager-webhook      1/1     1            1           42m
</span></span></span></code></pre></div><h2 id=a-self-signing-issuer>A Self-Signing Issuer<a class=td-heading-self-link href=#a-self-signing-issuer aria-label="Heading self-link"></a></h2><p>cert-manager can have any number of <em>issuer</em> configurations.
The simplest issuer type is <a href=https://cert-manager.io/docs/configuration/selfsigned/>SelfSigned</a>.
It simply takes the certificate request and signs it with the private key it generates for the TLS Secret.</p><pre tabindex=0><code>Self-signed certificates don&#39;t provide any help in establishing trust between certificates.
However, they are great for initial testing, due to their simplicity.
</code></pre><p>To install self-signing, run</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl apply -f - &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>apiVersion: cert-manager.io/v1
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>kind: ClusterIssuer
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>metadata:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  name: selfsigned
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>spec:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  selfSigned: {}
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>EOF
</span></span></span></code></pre></div><h2 id=creating-a-tls-gateway-listener>Creating a TLS Gateway Listener<a class=td-heading-self-link href=#creating-a-tls-gateway-listener aria-label="Heading self-link"></a></h2><p>We now have to patch the example Gateway to reference cert-manager:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl patch gateway/eg --patch <span style=color:#a40000>&#39;</span>
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>metadata:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  annotations:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    cert-manager.io/cluster-issuer: selfsigned
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    cert-manager.io/common-name: &#34;Hello World!&#34;
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>spec:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  listeners:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  - name: https
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    protocol: HTTPS
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    hostname: www.example.com
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    port: 443
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    tls:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      mode: Terminate
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      certificateRefs:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      - kind: Secret
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>        name: eg-https
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>&#39; --type=merge
</span></span></span></code></pre></div><p>You could instead create a new Gateway serving HTTPS, if you&rsquo;d prefer.
cert-manager doesn&rsquo;t care, but we&rsquo;ll keep it all together in this guide.</p><p>Nowadays, X.509 certificates don&rsquo;t use the subject Common Name for hostname matching, so you can set it to whatever you want, or leave it empty.
The important parts here are</p><ul><li>the annotation referencing the &ldquo;selfsigned&rdquo; ClusterIssuer we created above,</li><li>the <code>hostname</code>, which is required (but see <a href=https://github.com/cert-manager/cert-manager/issues/6051>#6051</a> for computing it based on attached HTTPRoutes), and</li><li>the named Secret, which is what cert-manager will create for us.</li></ul><p>The annotations are documented in <a href=https://cert-manager.io/docs/usage/gateway/#supported-annotations>Supported Annotations</a>.</p><p>Patching the Gateway makes cert-manager create a self-signed certificate within a few seconds.
Eventually, the Gateway becomes <code>Programmed</code> again:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl <span style=color:#204a87>wait</span> --for<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>condition</span><span style=color:#ce5c00;font-weight:700>=</span>Programmed gateway/eg
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>gateway.gateway.networking.k8s.io/eg condition met
</span></span></span></code></pre></div><h3 id=testing-the-gateway>Testing The Gateway<a class=td-heading-self-link href=#testing-the-gateway aria-label="Heading self-link"></a></h3><p>See <a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/#testing>Testing in Secure Gateways</a> for the general idea.</p><p>Since we have a self-signed certificate, <code>curl</code> will by default reject it, requiring the <code>-k</code> flag:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> curl -kv -HHost:www.example.com https://127.0.0.1/get
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>* Server certificate:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>*  subject: CN=Hello World!
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>&lt; HTTP/2 200
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span></code></pre></div><h3 id=how-cert-manager-and-envoy-gateway-interact>How cert-manager and Envoy Gateway Interact<a class=td-heading-self-link href=#how-cert-manager-and-envoy-gateway-interact aria-label="Heading self-link"></a></h3><p><em>This explains <a href=https://cert-manager.io/docs/concepts/>cert-manager Concepts</a> in an Envoy Gateway context.</em></p><p>In the interaction between the two, cert-manager does all the heavy lifting.
It subscribes to changes to Gateway resources (using the <a href=https://github.com/cert-manager/cert-manager/tree/master/pkg/controller/certificate-shim/gateways><code>gateway-shim</code> component</a>.)
For any Gateway it finds, it looks for any <a href=https://gateway-api.sigs.k8s.io/guides/tls/#listeners-and-tls>TLS listeners</a>, and the associated <code>tls.certificateRefs</code>.
Note that while Gateway API supports multiple refs here, Envoy Gateway only uses one.
cert-manager also looks at the <code>hostname</code> of the listener to figure out which hosts the certificate is expected to cover.
More than one listener can use the same certificate Secret, which means cert-manager needs to find all listeners using the same Secret before deciding what to do.
If the <code>certificatRef</code> points to a valid certificate, given the hostnames found in listeners, cert-manager has nothing to do.</p><p>If there is no valid certificate, or it is about to expire, cert-manager&rsquo;s <code>gateway-shim</code> creates a Certificate resource, or updates the existing one.
cert-manager then follows the <a href=https://cert-manager.io/docs/concepts/certificate/#certificate-lifecycle>Certificate Lifecycle</a>.
To know how to issue the certificate, an ClusterIssuer is configured, and referenced through annotations on the Gateway resource, which you did above.
Once a matching ClusterIssuer is found, that plugin does what needs to be done to acquire a signed certificate.</p><p>In the case of the ACME protocol (used by Let&rsquo;s Encrypt), cert-manager can also use an HTTP Gateway to solve the HTTP-01 challenge type.
This is the other side of cert-manager&rsquo;s Gateway API support:
the <a href=https://github.com/cert-manager/cert-manager/tree/master/pkg/issuer/acme/http/httproute.go>ACME issuer</a> creates a temporary <a href=https://gateway-api.sigs.k8s.io/api-types/httproute/>HTTPRoute</a>, lets the ACME server(s) query it, and deletes it again.</p><p>cert-manager then updates the Secret that the Gateway&rsquo;s listener points to in <code>tls.certificateRefs</code>.
Envoy Gateway picks up that the Secret has changed, and reloads the corresponding Envoy Proxy Deployments with the new private key and certificate.</p><p>As you can imagine, cert-manager requires quite broad permissions to update Secrets in any namespace, so the security-minded reader may want to look at the RBAC resources the Helm chart creates.</p><h2 id=using-the-acme-issuer-with-lets-encrypt-and-http-01>Using the ACME Issuer With Let&rsquo;s Encrypt and HTTP-01<a class=td-heading-self-link href=#using-the-acme-issuer-with-lets-encrypt-and-http-01 aria-label="Heading self-link"></a></h2><p>We will start using the Let&rsquo;s Encrypt staging environment, to spare their production environment.
Our Gateway already contains an HTTP listener, so we will use that for the HTTP-01 challenges.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> <span style=color:#000>CERT_MANAGER_CONTACT_EMAIL</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>git config user.email<span style=color:#204a87;font-weight:700>)</span>  <span style=color:#8f5902;font-style:italic># Or whatever...</span>
</span></span><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl apply -f - &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>apiVersion: cert-manager.io/v1
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>kind: ClusterIssuer
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>metadata:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  name: letsencrypt-staging
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>spec:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  acme:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    server: https://acme-staging-v02.api.letsencrypt.org/directory
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    email: &#34;$CERT_MANAGER_CONTACT_EMAIL&#34;
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    privateKeySecretRef:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      name: letsencrypt-staging-account-key
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    solvers:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    - http01:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>        gatewayHTTPRoute:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>          parentRefs:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>          - kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>            name: eg
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>            namespace: default
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>EOF
</span></span></span></code></pre></div><p>The important parts are</p><ul><li>using <code>spec.acme</code> with a server URI and contact email address, and</li><li>referencing our plain HTTP gateway so the challenge HTTPRoute is attached to the right place.</li></ul><p>Check the account registration process using the Ready condition:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl <span style=color:#204a87>wait</span> --for<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#000>condition</span><span style=color:#ce5c00;font-weight:700>=</span>Ready clusterissuer/letsencrypt-staging
</span></span><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl describe clusterissuer/letsencrypt-staging
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>Status:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  Acme:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Uri:                   https://acme-staging-v02.api.letsencrypt.org/acme/acct/123456789
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  Conditions:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Message:               The ACME account was registered with the ACME server
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Reason:                ACMEAccountRegistered
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Status:                True
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Type:                  Ready
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span></code></pre></div><p>Now we&rsquo;re ready to update the Gateway annotation to use this issuer instead:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl annotate --overwrite gateway/eg cert-manager.io/cluster-issuer<span style=color:#ce5c00;font-weight:700>=</span>letsencrypt-staging
</span></span></code></pre></div><p>The Gateway should be picked up by cert-manager, which will create a new certificate for you, and replace the Secret.</p><p>You should see a new CertificateRequest to track:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get certificaterequest
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME             APPROVED   DENIED   READY   ISSUER                REQUESTOR                                         AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>eg-https-xxxxx   True                True    selfsigned            system:serviceaccount:cert-manager:cert-manager   42m
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>eg-https-xxxxx   True                True    letsencrypt-staging   system:serviceaccount:cert-manager:cert-manager   42m
</span></span></span></code></pre></div><h3 id=testing-the-gateway-1>Testing The Gateway<a class=td-heading-self-link href=#testing-the-gateway-1 aria-label="Heading self-link"></a></h3><p>We still require the <code>-k</code> flag, since the Let&rsquo;s Encrypt staging environment CA is not widely trusted.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> curl -kv -HHost:www.example.com https://127.0.0.1/get
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>* Server certificate:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>*  subject: CN=Hello World!
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>*  issuer: C=US; O=(STAGING) Let&#39;s Encrypt; CN=(STAGING) Ersatz Edamame E1
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>&lt; HTTP/2 200
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span></code></pre></div><h2 id=using-the-lets-encrypt-production-environment>Using The Let&rsquo;s Encrypt Production Environment<a class=td-heading-self-link href=#using-the-lets-encrypt-production-environment aria-label="Heading self-link"></a></h2><p>Changing to the production environment is just a matter of replacing the server URI:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> <span style=color:#000>CERT_MANAGER_CONTACT_EMAIL</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span>git config user.email<span style=color:#204a87;font-weight:700>)</span>  <span style=color:#8f5902;font-style:italic># Or whatever...</span>
</span></span><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl apply -f - &lt;&lt;EOF
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>apiVersion: cert-manager.io/v1
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>kind: ClusterIssuer
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>metadata:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  name: letsencrypt
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>spec:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  acme:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    server: https://acme-v02.api.letsencrypt.org/directory  # Removed &#34;-staging&#34;.
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    email: &#34;$CERT_MANAGER_CONTACT_EMAIL&#34;
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    privateKeySecretRef:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      name: letsencrypt-account-key                         # Removed &#34;-staging&#34;.
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    solvers:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    - http01:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>        gatewayHTTPRoute:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>          parentRefs:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>          - kind: Gateway
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>            name: eg
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>            namespace: default
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>EOF
</span></span></span></code></pre></div><p>And now you can update the Gateway listener to point to <code>letsencrypt</code> instead:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl annotate --overwrite gateway/eg cert-manager.io/cluster-issuer<span style=color:#ce5c00;font-weight:700>=</span>letsencrypt
</span></span></code></pre></div><p>As before, track it by looking at CertificateRequests.</p><h3 id=testing-the-gateway-2>Testing The Gateway<a class=td-heading-self-link href=#testing-the-gateway-2 aria-label="Heading self-link"></a></h3><p>Once the certificate has been replaced, we should finally be able to get rid of the <code>-k</code> flag:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> curl -v -HHost:www.example.com --resolve www.example.com:127.0.0.1 https://www.example.com/get
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>* Server certificate:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>*  subject: CN=Hello World!
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>*  issuer: C=US; O=Let&#39;s Encrypt; CN=R3
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>&lt; HTTP/2 200
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span></code></pre></div><h2 id=collecting-garbage>Collecting Garbage<a class=td-heading-self-link href=#collecting-garbage aria-label="Heading self-link"></a></h2><p>You probably want to set the <code>cert-manager.io/revision-history-limit</code> annotation on your Gateway to make cert-manager prune the CertificateRequest history.</p><p>cert-manager <a href=https://github.com/cert-manager/cert-manager/blob/c5e6bf39d688d202592318eaf91988466a7ee37b/pkg/controller/certificate-shim/sync.go#L171>deletes unused Certificate resources</a>, and they are updated in-place when possible, so there should be no need for cleaning up Certificate resources.
The deletion is based on whether a Gateway still holds a <code>tls.certificateRefs</code> that requires the Certificate.</p><p>If you remove a TLS listener from a Gateway, you may still have a Secret lingering.
cert-manager can clean it up using <a href=https://cert-manager.io/docs/usage/certificate/#cleaning-up-secrets-when-certificates-are-deleted>a flag</a>.</p><h2 id=issuer-namespaces>Issuer Namespaces<a class=td-heading-self-link href=#issuer-namespaces aria-label="Heading self-link"></a></h2><p>We have used ClusterIssuer resources in this tutorial.
They are not bound to any namespace, and will read annotations from Gateways in any namespace.
You could also use <a href=https://cert-manager.io/docs/concepts/issuer/>Issuer</a>, which is bound to a namespace.
This is useful e.g. if you want to use different ACME accounts for different namespaces.</p><p>If you change the issuer kind, you also need to change the annotation key from <code>cert-manager.io/clusterissuer</code> to <code>cert-manager.io/issuer</code>.</p><h2 id=using-externaldns>Using ExternalDNS<a class=td-heading-self-link href=#using-externaldns aria-label="Heading self-link"></a></h2><p>The <a href=https://kubernetes-sigs.github.io/external-dns/latest/>ExternalDNS</a> controller maintains DNS records based on Kubernetes resources.
Together with cert-manager, this can be used to fully automate hostname management.
It can use various source resources, among them Gateway Routes.
Just specify a Gateway Route resource, let ExternalDNS create the domain records, and then cert-manager the TLS certificate.</p><p><a href=https://kubernetes-sigs.github.io/external-dns/latest/tutorials/gateway-api/>The tutorial on Gateway API</a> uses kubectl.
They also have a <a href=https://github.com/kubernetes-sigs/external-dns/blob/master/charts/external-dns/README.md>Helm chart</a>, which is easier to customize.
The only thing relevant to Envoy Gateway is to set the sources:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#8f5902;font-style:italic># values.yaml</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>sources</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#000>gateway-httproute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#000>gateway-grpcroute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#000>gateway-tcproute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#000>gateway-tlsroute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span><span style=display:flex><span><span style=color:#f8f8f8;text-decoration:underline></span>- <span style=color:#000>gateway-udproute</span><span style=color:#f8f8f8;text-decoration:underline>
</span></span></span></code></pre></div><h2 id=monitoring-progress--troubleshooting>Monitoring Progress / Troubleshooting<a class=td-heading-self-link href=#monitoring-progress--troubleshooting aria-label="Heading self-link"></a></h2><p>You can monitor progress in several ways:</p><p>The Issuer has a Ready condition (though this is rather <a href=https://github.com/cert-manager/cert-manager/blob/c5e6bf39d688d202592318eaf91988466a7ee37b/pkg/issuer/selfsigned/setup.go#L32>boring</a> for the <code>selfSigned</code> type):</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get issuer --all-namespaces
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAMESPACE   NAME         READY   AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>default     selfsigned   True    42m
</span></span></span></code></pre></div><p>The Gateway will say when it has an invalid certificate:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl describe gateway/eg
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>    Conditions:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Message:               Secret default/eg-https does not exist.
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Reason:                InvalidCertificateRef
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Status:                False
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Type:                  ResolvedRefs
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Message:               Listener is invalid, see other Conditions for details.
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Reason:                Invalid
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Status:                False
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>      Type:                  Programmed
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>Events:
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  Type     Reason     Age    From                       Message
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  ----     ------     ----   ----                       -------
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>  Warning  BadConfig  42m    cert-manager-gateway-shim  Skipped a listener block: spec.listeners[1].hostname: Required value: the hostname cannot be empty
</span></span></span></code></pre></div><p>The main question is if cert-manager has picked up on the Gateway.
I.e., has it created a Certificate for it?
The above <code>describe</code> contains an event from <code>cert-manager-gateway-shim</code> telling you of one such issue.
Be aware that if you have a non-TLS listener in the Gateway, like we did, there will be events saying it is not eligible, which is of course expected.</p><p>Another option is looking at Deployment logs.
The cert-manager logs are not very verbose by default, but setting the Helm value <code>global.logLevel</code> to 6 will enable all debug logs (the default is 2.)
This will make them verbose enough to say why a Gateway wasn&rsquo;t considered (e.g. missing <code>hostname</code>, or <code>tls.mode</code> is not <code>Terminate</code>.)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl logs -n cert-manager deployment/cert-manager
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>...
</span></span></span></code></pre></div><p>Simply listing Certificate resources may be useful, even if it just gives a yes/no answer:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get certificate --all-namespaces
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAMESPACE   NAME       READY   SECRET     AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>default     eg-https   True    eg-https   42m
</span></span></span></code></pre></div><p>If there is a Certificate, then the <code>gateway-shim</code> has recognized the Gateway.
But is there a CertificateRequest for it?
(BTW, don&rsquo;t confuse this with a CertificateSigningRequest, which is a Kubernetes core resource type representing the same thing.)</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get certificaterequest --all-namespaces
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAMESPACE   NAME             APPROVED   DENIED   READY   ISSUER       REQUESTOR                                         AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>default     eg-https-xxxxx   True                True    selfsigned   system:serviceaccount:cert-manager:cert-manager   42m
</span></span></span></code></pre></div><p>The ACME issuer also has <code>Order</code> and <code>Challenge</code> resources to watch:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get order --all-namespaces -o wide
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME                                                     STATE     ISSUER                REASON   AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>order.acme.cert-manager.io/envoy-https-xxxxx-123456789   pending   letsencrypt-staging            42m
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic></span><span style=color:#a40000>
</span></span></span><span style=display:flex><span><span style=color:#a40000></span><span style=color:#8f5902>$</span> kubectl get challenge --all-namespaces
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME                                                                    STATE     DOMAIN            AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>challenge.acme.cert-manager.io/envoy-https-xxxxx-123456789-1234567890   pending   www.example.com   42m
</span></span></span></code></pre></div><p>Using <code>kubetctl get -o wide</code> or <code>kubectl describe</code> on the Challenge will explain its state more.</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get order --all-namespaces -o wide
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME                                                     STATE   ISSUER                REASON   AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>order.acme.cert-manager.io/envoy-https-xxxxx-123456789   valid   letsencrypt-staging            42m
</span></span></span></code></pre></div><p>Finally, since cert-manager creates the Secret referenced by the Gateway listener as its last step, we can also look for that:</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-console data-lang=console><span style=display:flex><span><span style=color:#8f5902>$</span> kubectl get secret secret/eg-https
</span></span><span style=display:flex><span><span style=color:#000;font-style:italic>NAME       TYPE                DATA   AGE
</span></span></span><span style=display:flex><span><span style=color:#000;font-style:italic>eg-https   kubernetes.io/tls   3      42m
</span></span></span></code></pre></div><h2 id=clean-up>Clean Up<a class=td-heading-self-link href=#clean-up aria-label="Heading self-link"></a></h2><ul><li>Uninstall cert-manager: <code>helm uninstall --namespace cert-manager cert-manager</code></li><li>Delete the <code>cert-manager</code> namespace: <code>kubectl delete namespace/cert-manager</code></li><li>Delete the <code>https</code> listener from <code>gateway/eg</code>.</li><li>Delete <code>secret/eg-https</code>.</li></ul><h2 id=see-also>See Also<a class=td-heading-self-link href=#see-also aria-label="Heading self-link"></a></h2><ul><li><a href=/eg-pr-preview/5-test-docs-preview/v1.0/tasks/security/secure-gateways/>Secure Gateways</a></li><li><a href=https://cert-manager.io/docs/usage/gateway/>Securing gateway.networking.k8s.io Gateway Resources</a></li></ul></div></main></div></div><footer class="td-footer row d-print-none"><div class=container-fluid><div class="row mx-md-2"><div class="td-footer__left col-6 col-sm-4 order-sm-1"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title="User mailing list" aria-label="User mailing list"><a target=_blank rel=noopener href=mailto:envoy-users@googlegroups.com aria-label="User mailing list"><i class="fa fa-envelope"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Twitter aria-label=Twitter><a target=_blank rel=noopener href=https://twitter.com/EnvoyProxy aria-label=Twitter><i class="fab fa-twitter"></i></a></li></ul></div><div class="td-footer__right col-6 col-sm-4 order-sm-3"><ul class=td-footer__links-list><li class=td-footer__links-item data-bs-toggle=tooltip title=GitHub aria-label=GitHub><a target=_blank rel=noopener href=https://github.com/envoyproxy/gateway aria-label=GitHub><i class="fab fa-github"></i></a></li><li class=td-footer__links-item data-bs-toggle=tooltip title=Slack aria-label=Slack><a target=_blank rel=noopener href=https://envoyproxy.slack.com/archives/C03E6NHLESV aria-label=Slack><i class="fab fa-slack"></i></a></li></ul></div><div class="td-footer__center col-12 col-sm-4 py-2 order-sm-2"><span class=td-footer__copyright>&copy;
2025
<span class=td-footer__authors>The Envoy Gateway Authors</span></span><span class=td-footer__all_rights_reserved>All Rights Reserved</span><p class="td-footer__about mt-2"><a href=/eg-pr-preview/5-test-docs-preview/about/>About Envoy Gateway</a></p></div></div></div></footer></div><script src=/eg-pr-preview/5-test-docs-preview/js/main.min.69e2c1ae9320465ab10236d9ef752c6a4442c54b48b883b17c497b7c7d96a796.js integrity="sha256-aeLBrpMgRlqxAjbZ73UsakRCxUtIuIOxfEl7fH2Wp5Y=" crossorigin=anonymous></script><script defer src=/eg-pr-preview/5-test-docs-preview/js/click-to-copy.min.73478a7d4807698aed7e355eb23f9890ca18fea3158604c8471746d046702bad.js integrity="sha256-c0eKfUgHaYrtfjVesj+YkMoY/qMVhgTIRxdG0EZwK60=" crossorigin=anonymous></script><script src=/eg-pr-preview/5-test-docs-preview/js/tabpane-persist.js></script></body></html>